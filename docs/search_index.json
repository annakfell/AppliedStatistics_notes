[
["index.html", "Applied Statistics Preface", " Applied Statistics Robin A. Donatello and Edward A. Roualdes Last Updated 2018-11-06 Preface This document is a set of course notes for several Applied Statistics courses at California State University, Chico. This is not a textbook replacement, and topics covered will vary depending on the instructor. To make this clear we use the term notebook to refer to this document so as not to be confused with a traditional textbook. Some data and examples in this notebook are drawn from Practical Multivariate Analysis, 5th ed, Afifi, May, Clark and used with permission by the authors. This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. "],
["data-prep.html", "Chapter 1 Preparing Data for Analysis", " Chapter 1 Preparing Data for Analysis Write an introduction here. 1.0.1 Reproducible Workflows PrepareData Why do we need a codebook? You are your own collaborator 6 months from now. Make sure you will be able to understand what you were doing. Investing the time to do things clearly and in a reproducible manner will make your future self happy. Comment your code with explanations and instructions. How did you get from point A to B? Why did you recode this variable in this manner? We need to record those steps (not just for posterity). This means your code must be saved in a script file. Include sufficient notes to yourself describing what you are doing and why. For R, this can be in a .R or .RMD file. I always prefer the latter. For SPSS you can specify to paste the syntax and copy into a .sps script file. For SAS you’ll use a .sas file For STATA this will be a .do file Repro Figure Credits: Roger Peng What stages of this pipeline can we conduct using R Markdown? 1.0.2 Data Management Questions to ask yourself (and the data) while preparing a data management file. Do you need to code out missing data? Do you need to code out skip patterns? Do you need to make response codes more logical? Do you need to recode categorical variables to quantitative? Do you need to create secondary variables? Many of these answers will come only after you look at your data. This can be looking at the raw data itself but also looking at tables and charts generated from the data. "],
["import-data.html", "1.1 Import data", " 1.1 Import data This section uses the raw depression data set from the Afifi et.al. textbook. library(ggplot2) depress &lt;- read.table(&quot;https://norcalbiostat.netlify.com/data/Depress.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) SPSS syntax will look similar like this: GET DATA /TYPE=XLSX /FILE=&#39;C:\\path\\to\\file.xlsx&#39; /SHEET=name &#39;Name-of-Sheet&#39; /CELLRANGE=full /READNAMES=on /ASSUMEDSTRWIDTH=32767. EXECUTE. DATASET NAME DataSetExcel WINDOW=FRONT. Reference on importing data into SPSS: https://libguides.library.kent.edu/SPSS/ImportData. The absolute first thing you should do is to look at your raw data table. Are the column headers variable names? Did all the rows get read in? Are there any extra columns or rows included? 1.1.1 Renaming varible names for sanity sake Turn all variable names to lower case. This is especially frustrating for R and STATA users where syntax is case sensitive. This is completely optional but helpful names(depress) &lt;- tolower(names(depress)) You should also rename any variable that has spaces or special characters in the name. "],
["missing-data.html", "1.2 Missing data", " 1.2 Missing data In Excel, missing data can show up as a blank cell. In SPSS it is represented as a . period. R displays missing data as NA values. Missing Data in SPSS: https://stats.idre.ucla.edu/spss/modules/missing-data/ Why would data be missing? Other than the obvious data entry errors, tech glitches or just non-cooperative plants or people, sometimes values are out of range and you would rather delete them than change their value (data edit). Lets look at the religion variable in the depression data set. table(depress$relig, useNA=&quot;always&quot;) ## ## 1 2 3 4 6 &lt;NA&gt; ## 155 51 30 56 2 0 Looking at the codebook, there is no category 6 for religion. Let’s change all values to NA. depress$relig[depress$relig==6] &lt;- NA This code says take all rows where relig is equal to 6, and change them to NA. Confirm recode. table(depress$relig, useNA=&quot;always&quot;) ## ## 1 2 3 4 &lt;NA&gt; ## 155 51 30 56 2 Notice the use of the useNA=&quot;always&quot; argument. If we just looked at the base table without this argument, we would have never known there was missing data! table(depress$relig) ## ## 1 2 3 4 ## 155 51 30 56 What about continuous variables? Well there happens to be no other missing data in this data set, so let’s make up a set of 7 data points stored in a variable named y. y &lt;- c(1, 2, 3, NA, 4, NA, 6) y ## [1] 1 2 3 NA 4 NA 6 The #1 way to identify missing data in a continuous variable is by looking at the summary() values. mean(y) ## [1] NA summary(y) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 1.0 2.0 3.0 3.2 4.0 6.0 2 mean(y, na.rm=TRUE) ## [1] 3.2 In R, any arithmetic function (like addition, multipliation) on missing data results in a missing value. The na.rm=TRUE toggle tells R to calculate the complete case mean. This is a biased measure of the mean, but missing data is a topic worthy of it’s own course. "],
["identifying-variable-types.html", "1.3 Identifying Variable Types", " 1.3 Identifying Variable Types The str function is short for structure. This shows you the variable names, what data types R thinks each variable are, and some of the raw data. You can also use the view() function to open the data as a simliar spreadsheet format, or head() to see the top 6 rows of the data. The latter is sometimes less than helpful for a very large data set. str(depress) ## &#39;data.frame&#39;: 294 obs. of 37 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ sex : int 2 1 2 2 2 1 2 1 2 1 ... ## $ age : int 68 58 45 50 33 24 58 22 47 30 ... ## $ marital : int 5 3 2 3 4 2 2 1 2 2 ... ## $ educat : int 2 4 3 3 3 3 2 3 3 2 ... ## $ employ : int 4 1 1 3 1 1 5 1 4 1 ... ## $ income : int 4 15 28 9 35 11 11 9 23 35 ... ## $ relig : int 1 1 1 1 1 1 1 1 2 4 ... ## $ c1 : int 0 0 0 0 0 0 2 0 0 0 ... ## $ c2 : int 0 0 0 0 0 0 1 1 1 0 ... ## $ c3 : int 0 1 0 0 0 0 1 2 1 0 ... ## $ c4 : int 0 0 0 0 0 0 2 0 0 0 ... ## $ c5 : int 0 0 1 1 0 0 1 2 0 0 ... ## $ c6 : int 0 0 0 1 0 0 0 1 3 0 ... ## $ c7 : int 0 0 0 0 0 0 0 0 0 0 ... ## $ c8 : int 0 0 0 3 3 0 2 0 0 0 ... ## $ c9 : int 0 0 0 0 3 1 2 0 0 0 ... ## $ c10 : int 0 0 0 0 0 0 0 0 0 0 ... ## $ c11 : int 0 0 0 0 0 0 0 0 0 0 ... ## $ c12 : int 0 1 0 0 0 1 0 0 3 0 ... ## $ c13 : int 0 0 0 0 0 2 0 0 0 0 ... ## $ c14 : int 0 0 1 0 0 0 0 0 3 0 ... ## $ c15 : int 0 1 1 0 0 0 3 0 2 0 ... ## $ c16 : int 0 0 1 0 0 2 0 1 3 0 ... ## $ c17 : int 0 1 0 0 0 1 0 1 0 0 ... ## $ c18 : int 0 0 0 0 0 0 0 1 0 0 ... ## $ c19 : int 0 0 0 0 0 0 0 1 0 0 ... ## $ c20 : int 0 0 0 0 0 0 1 0 0 0 ... ## $ cesd : int 0 4 4 5 6 7 15 10 16 0 ... ## $ cases : int 0 0 0 0 0 0 0 0 1 0 ... ## $ drink : int 2 1 1 2 1 1 2 2 1 1 ... ## $ health : int 2 1 2 1 1 1 3 1 4 1 ... ## $ regdoc : int 1 1 1 1 1 1 1 2 1 1 ... ## $ treat : int 1 1 1 2 1 1 1 2 1 2 ... ## $ beddays : int 0 0 0 0 1 0 0 0 1 0 ... ## $ acuteill: int 0 0 0 0 1 1 1 1 0 0 ... ## $ chronill: int 1 1 0 1 0 1 1 0 1 0 ... Right away this tells me that R thinks all variables are numeric integers, not categorical variables. This will have to be changed. We’ll get to that in a moment. In SPSS you’ll the following set of icons to tell you what data types the program thinks each column is: Consider the variable that measures marital status. table(depress$marital) ## ## 1 2 3 4 5 ## 73 127 43 13 38 str(depress$marital) ## int [1:294] 5 3 2 3 4 2 2 1 2 2 ... class(depress$marital) ## [1] &quot;integer&quot; What data type does R see this variable as? When variables have numerical levels it is necessary to ensure that the program knows it is a factor variable. The following code uses the factor() function to take the marital status variable and convert it into a factor variable with specified labels that match the codebook. depress$marital &lt;- factor(depress$marital, labels = c(&quot;Never Married&quot;, &quot;Married&quot;, &quot;Divorced&quot;, &quot;Separated&quot;, &quot;Widowed&quot;)) It is important to confirm the recode worked. If it did not you will have to re-read in the raw data set again since the variable sex was replaced. table(depress$marital) ## ## Never Married Married Divorced Separated Widowed ## 73 127 43 13 38 class(depress$marital) ## [1] &quot;factor&quot; Create a boxplot of income across marital status category. ggplot(depress, aes(y=income, x=marital)) + geom_boxplot() Boxplots are nice because they clearly show the range where 50% of the data lie and any potential outliers. Boxplots can also indicate skewness, but sometimes it is helpful to visualize the location of the mean as well as the median. ggplot2 has a nice stat_summary layer that will calculate and add the means to the current plot. ggplot(depress, aes(y=income, x=marital)) + geom_boxplot() + stat_summary(fun.y=mean, colour=&quot;blue&quot;, size=3, geom=&quot;point&quot;) "],
["outliers.html", "1.4 Outliers", " 1.4 Outliers Let’s look at the age variable in the depression data set. par(mfrow=c(1,2)) boxplot(depress$age) hist(depress$age) Just looking at the data graphically raises no red flags. The boxplot shows no outlying values and the histogram does not look wildly skewed. This is where knowledge about the data set is essential. The codebook does not provide a valid range for the data, but the description of the data starting on page 3 in the textbook clarifies that this data set is on adults. In the research world, this specifies 18 years or older. Now look back at the graphics. See anything odd? It appears as if the data go pretty far below 20, possibly below 18. Let’s check the numerical summary to get more details. summary(depress$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.00 28.00 42.50 44.38 59.00 89.00 The minimum value is a 9, which is outside the range of valid values for this variable. This is where you, as a statistician, data analyst or researcher goes back to the PI and asks for advice. Should this data be set to missing, or edited in a way that changes this data point into a valid piece of data. As an example of a common data entry error, and for demonstration purposes, I went in and changed a 19 to a 9. So the correct thing to do here is to change that 9, back to a 19. This is a very good use of the ifelse() function. depress$age &lt;- ifelse(depress$age==9, 19, depress$age) The logical statement is depress$age9. Wherever this is true, replace the value of depress$age with 19, wherever this is false then keep the value of depress$age unchanged (by “replacing” the new value with the same old value). Alternatively, you can change that one value using bracket notation. Here you are specifying that you only want the rows where age==9, and directly assign a value of 19 to those rows. depress$age[depress$age==9] &lt;- 19 Confirm the recode. summary(depress$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 18.00 28.00 42.50 44.41 59.00 89.00 Looks like it worked. "],
["creating-secondary-variables.html", "1.5 Creating secondary variables", " 1.5 Creating secondary variables 1.5.1 Collapsing variables into fewer categories For unbiased and accurate results of a statistical analysis, sufficient data has to be present. Often times once you start slicing and dicing the data to only look at certain groups, or if you are interested in the behavior of certain variables across levels of another variable, sometimes you start to run into small sample size problems. For example, consider marital status again. There are only 13 people who report being separated. This could potentially be too small of a group size for valid statistical analysis. One way to deal with insufficient data within a certain category is to collapse categories. The following code uses the recode() function from the car package to create a new variable that I am calling marital2 that combines the Divorced and Separated levels. library(car) marital2 &lt;- recode(depress$marital, &quot;&#39;Divorced&#39; = &#39;Sep/Div&#39;; &#39;Separated&#39; = &#39;Sep/Div&#39;&quot;) Always confirm your recodes. table(depress$marital, marital2, useNA=&quot;always&quot;) ## marital2 ## Married Never Married Sep/Div Widowed &lt;NA&gt; ## Never Married 0 73 0 0 0 ## Married 127 0 0 0 0 ## Divorced 0 0 43 0 0 ## Separated 0 0 13 0 0 ## Widowed 0 0 0 38 0 ## &lt;NA&gt; 0 0 0 0 0 This confirms that records where marital (rows) is Divorced or Separated have the value of Sep/Div for marital2 (columns). And that no missing data crept up in the process. Now I can drop the temporary marital2 variable and actually fix marital. (keeping it clean) depress$marital &lt;- recode(depress$marital, &quot;&#39;Divorced&#39; = &#39;Sep/Div&#39;; &#39;Separated&#39; = &#39;Sep/Div&#39;&quot;) rm(marital2) 1.5.2 Binning a continuous variable into categorical ranges. Let’s create a new variable that categorizes income into the following ranges: &lt;30, [30, 40), [40,50), [50, 60), 60+. The easiest way is to use the cut2 function in the package Hmisc. Note you don’t have to load the package fully to use a function from within that package. Useful for times when you only need to use a function once or twice. depress$inc_cut &lt;- Hmisc::cut2(depress$income, cuts=c(30,40,50,60)) table(depress$inc_cut) ## ## [ 2,30) [30,40) [40,50) [50,60) [60,65] ## 231 28 16 9 10 1.5.3 Dichotomizing Dichotomous variables tend to be binary indicator variables where a code of 1 is the level you’re interested in. For example, gender is coded as 2=Female and 1=Male. This is in the right direction but it needs to be 0/1. depress$sex &lt;- depress$sex -1 table(depress$sex) ## ## 0 1 ## 111 183 0/1 binary coding is mandatory for many analyses. One simple reason is that now you can calculate the mean and interpret it as a proportion. mean(depress$sex) ## [1] 0.622449 62% of individuals in this data set are female. Sometimes the data is recorded as 1/2 (Yes/No), so just subtracting from 1 doesn’t create a positive indicator of the variable. For example, drink=1 if they are a regular drinker, and drink=2 if they are not. We want not drinking to be coded as 0, not 2. table(depress$drink) ## ## 1 2 ## 234 60 The ifelse() function says that if depress$DRINK has a value equal to 2 ==2, then change the value to 0. Otherwise leave it alone. depress$drink &lt;- ifelse(depress$drink==2, 0, depress$drink) table(depress$drink) ## ## 0 1 ## 60 234 1.5.4 Sum or Average values across multiple variables The Center for Epidemiologic Studies Depression Scale (CESD) is series of questions asked to a person to measure their level of depression. CESD is calculated as the sum of all 20 component variables, and is already on this data set. Let’s create a new variable named sleep as subscale for sleep quality by adding up question numbers 5, 11, and 19. Reference: http://cesd-r.com/cesdr/ depress$sleep &lt;- depress$c5 + depress$c11 + depress$c19 ## # depress &lt;- depress %&gt;% mutate(sleep = c5+c11+c19) # Not run. dplyr example summary(depress$sleep) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 0.000 1.000 1.167 2.000 7.000 "],
["transformations-for-normality.html", "1.6 Transformations for Normality", " 1.6 Transformations for Normality Let’s look at assessing normal distributions using the cleaned depression data set. rm(depress) # remove the current version that was used in the previous part of this markdown file depress &lt;- read.table(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) hist(depress$income, prob=TRUE, xlab=&quot;Annual income (in thousands)&quot;, main=&quot;Histogram and Density curve of Income&quot;, ylab=&quot;&quot;) lines(density(depress$income), col=&quot;blue&quot;) summary(depress$income) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.00 9.00 15.00 20.57 28.00 65.00 The distribution of annual income is slightly skewed right with a mean of $20.5k per year and a median of $15k per year income. The range of values goes from $2k to $65k. Reported income above $40k appear to have been rounded to the nearest $10k, because there are noticeable peaks at $40k, $50k, and $60k. In general, transformations are more effective when the the standard deviation is large relative to the mean. One rule of thumb is if the sd/mean ratio is less than 1/4, a transformation may not be necessary. sd(depress$income) / mean(depress$income) ## [1] 0.743147 Alternatively Hoaglin, Mosteller and Tukey (1985) showed that if the largest observation divided by the smallest observation is over 2, then the data may not be sufficiently variable for the transformation to be decisive. max(depress$income) / (min(depress$income)+.1) ## [1] 30.95238 Note these rules are not meaningful for data without a natural zero. Another common method of assessing normality is to create a normal probability (or normal quantile) plot. qqnorm(depress$income);qqline(depress$income, col=&quot;red&quot;) The points on the normal probability plot do not follow the red reference line very well. The dots show a more curved, or U shaped form rather than following a linear line. This is another indication that the data is skewed and a transformation for normality should be created. Create three new variables: log10inc as the log base 10 of Income, loginc as the natural log of Income, and xincome which is equal to the negative of one divided by the cubic root of income. log10inc &lt;- log10(depress$income) loginc &lt;- log(depress$income) xincome &lt;- -1/(depress$income)^(-1/3) Create a single plot that display normal probability plots for the original, and each of the three transformations of income. Use the base graphics grid organizer par(mfrow=c(r,c)) where r is the number of rows and c is the number of columns. Which transformation does a better job of normalizing the distribution of Income? par(mfrow=c(2,2)) # Try (4,1) and (1,4) to see how this works. qqnorm(depress$income, main=&quot;Income&quot;); qqline(depress$income,col=&quot;blue&quot;) qqnorm(log10inc, main=&quot;Log 10&quot;); qqline(log10inc, col=&quot;blue&quot;) qqnorm(loginc, main = &quot;Natural Log&quot;); qqline(loginc, col=&quot;blue&quot;) qqnorm(xincome, main=&quot;-1/cuberoot(income)&quot;); qqline(xincome, col=&quot;blue&quot;) "],
["saving-your-changes.html", "1.7 Saving your changes", " 1.7 Saving your changes You’ve just made a ton of changes! Save or export the new data set to your computer. Edit the codebook to reflect the changes that you made. Save this codebook with todays date as well. Keep the data, codebook and data management file in the same folder. The Sys.Date() function takes the current date from your computer. The value is then formatted nicely for human consumption and added (pasted) to the file name before written to the working directory as a new text file. date &lt;- format(Sys.Date(), &quot;%m%d%y&quot;) filename &lt;- paste(&quot;depress_&quot;, date, &quot;.txt&quot;, sep=&quot;&quot;) write.table(depress, filename, sep=&quot;\\t&quot;, row.names=FALSE) "],
["wide-vs-long-data.html", "1.8 Wide vs. Long data", " 1.8 Wide vs. Long data The data on Lung function originally was recorded in wide format, with separate variables for mother’s and father’s FEV1 score (MFEV1 and FFEV). In this format, the data is one record per family. fev &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/Lung_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) head(fev) ## ID AREA FSEX FAGE FHEIGHT FWEIGHT FFVC FFEV1 MSEX MAGE MHEIGHT MWEIGHT ## 1 1 1 1 53 61 161 391 3.23 2 43 62 136 ## 2 2 1 1 40 72 198 441 3.95 2 38 66 160 ## 3 3 1 1 26 69 210 445 3.47 2 27 59 114 ## 4 4 1 1 34 68 187 433 3.74 2 36 58 123 ## 5 5 1 1 46 61 121 354 2.90 2 39 62 128 ## 6 6 1 1 44 72 153 610 4.91 2 36 66 125 ## MFVC MFEV1 OCSEX OCAGE OCHEIGHT OCWEIGHT OCFVC OCFEV1 MCSEX MCAGE ## 1 370 3.31 2 12 59 115 296 2.79 NA NA ## 2 411 3.47 1 10 56 66 323 2.39 NA NA ## 3 309 2.65 1 8 50 59 114 1.11 NA NA ## 4 265 2.06 2 11 57 106 256 1.85 1 9 ## 5 245 2.33 1 16 61 88 260 2.47 2 12 ## 6 349 3.06 1 15 67 100 389 3.55 1 13 ## MCHEIGHT MCWEIGHT MCFVC MCFEV1 YCSEX YCAGE YCHEIGHT YCWEIGHT YCFVC ## 1 NA NA NA NA NA NA NA NA NA ## 2 NA NA NA NA NA NA NA NA NA ## 3 NA NA NA NA NA NA NA NA NA ## 4 49 56 159 1.30 NA NA NA NA NA ## 5 60 85 268 2.34 2 10 50 53 154 ## 6 57 87 276 2.37 2 10 55 72 195 ## YCFEV1 ## 1 NA ## 2 NA ## 3 NA ## 4 NA ## 5 1.43 ## 6 1.69 To analyze the effect of gender on FEV, the data need to be in long format, with a single variable for fev and a separate variable for gender. The following code chunk demonstrates one method of combining data on height, gender, age and FEV1 for both males and females. fev2 &lt;- data.frame(gender = c(fev$FSEX, fev$MSEX), rev = c(fev$FFEV1, fev$MFEV1), ht = c(fev$FHEIGHT, fev$MHEIGHT), age = c(fev$FAGE, fev$MAGE)) fev2$gender &lt;- factor(fev2$gender, labels=c(&quot;M&quot;, &quot;F&quot;)) head(fev2) ## gender rev ht age ## 1 M 3.23 61 53 ## 2 M 3.95 72 40 ## 3 M 3.47 69 26 ## 4 M 3.74 68 34 ## 5 M 2.90 61 46 ## 6 M 4.91 72 44 Nearly all analysis procedures and most graphing procedures require the data to be in long format. There are several R packages that can help with this including reshape2 and tidyr. "],
["dealing-with-missing-data-post-analysis.html", "1.9 Dealing with missing data post-analysis", " 1.9 Dealing with missing data post-analysis Case when: you want to add model predictions to the data set, but you have missing data that was automatically dropped prior to analysis. If your original data had missing values, here is one way to get the factor scores for available data back onto the data set. Alternatively you can look into methods to conduct factor analysis with missing data (FactomineR) If no ID column exists, create one: id = 1:NROW(data) Use select() to extract ID and all variables used in the factor analysis Do na.omit() Conduct factor analysis on this subsetted data set Use bind_cols() to add columns containing factor scores to this subsetted data set as described above Use select() to only keep the ID and the factor score variables Then left_join() the factor scores back to the original data, using the ID variable as the joining key. "],
["data-viz.html", "Chapter 2 Visualizing Data", " Chapter 2 Visualizing Data Visualizing your data is hands down the most important thing you can learn to do. There are links to additional resources at the end of this document for additional learning. There are two audiences in mind when creating data visualizations: For your eyes only (FYEO). These are quick and dirty plots, without annotation. Meant to be looked at once or twice. To share with others. These need to completely stand on their own. Axes labels, titles, colors as needed, possibly captions. You will see, and slowly learn, how to add these annotations and how to clean up your graphics to make them sharable. ggplot2 already does a lot of this work for you. We will also use the two most common methods used to create plots. 1) Base graphics, 2) the ggplot2 package. Each have their own advantages and disadvantages. If you have not done so already, go ahead and install the ggplot2 package now. For almost every plot discussed we will create two types of plots FYEO - using base graphics. (Base == Comes with R) Very powerful, but can be technical. FYEO - using ggplot2. Each have their own advantages and disadvantages. As time permits I will update each section with a third type of plot - Sharable - Contains all bells and whistles needed to make it presentable to others. Your task, should you choose to accept, is to follow along through this tutorial and at each step try to reproduce the plot shown. You can accomplish this by simply copying and pasting the syntax into a new R code (or R Markdown) document. "],
["the-syntax-of-ggplot.html", "2.1 The syntax of ggplot", " 2.1 The syntax of ggplot The reason we use the functions in ggplot2 is for consistency in the structure of it’s arguments. Here is a bare bones generic plotting function: ggplot(data, aes(x=x, y=y, col=col, fill=fill, group=group)) + geom_THING() 2.1.1 Required arguments data: What data set is this plot using? This is ALWAYS the first argument. aes(): This is the aestetics of the plot. What’s variable is on the x, what is on the y? Do you want to color by another variable, perhaps fill some box by the value of another variable, or group by a variable. geom_THING(): Every plot has to have a geometry. What is the shape of the thing you want to plot? Do you want to plot points - use geom_points(). Want to connect those points with a line? Use geom_lines(). We will see many varieties in this lab. 2.1.2 Optional but helpful arguments ggtitle: This is the overall plot title xlab() and ylab() axis titles. scale_xy_blah to extend limits scale_fill_blah to specifying a fixed color, and change auto legend title themes For a full , and comprehensive tutorial and reference guide on how to do nearly anything in ggplot – this is by far my favorite reference http://www.cookbook-r.com/Graphs/ I reference things in there (like how to remove or change the title of a legend) constantly. "],
["the-data.html", "2.2 The Data", " 2.2 The Data We will use a subset of the diamonds dataset that comes with the ggplot2 package. This dataset contains the prices and other attributes of almost 54,000 diamonds. Review ?diamonds to learn about the variables we will be using. data(&quot;diamonds&quot;) set.seed(1410) # Make the sample reproducible dsmall &lt;- diamonds[sample(nrow(diamonds), 1000), ] "],
["univariate-categorical-variables.html", "2.3 Univariate Categorical variables", " 2.3 Univariate Categorical variables Both Nominal and Ordinal data types can be visualized using the same methods: tables, barcharts and pie charts. 2.3.1 Tables Tables are the most common way to get summary statistics of a categorical variable. The table() function produces a frequency table, where each entry represents the number of records in the data set holding the corresponding labeled value. table(dsmall$cut) ## ## Fair Good Very Good Premium Ideal ## 27 83 226 277 387 There are 27 Fair quality diamonds, 83 good quality and 387 Ideal quality diamonds in this sample. 2.3.2 Barcharts / Barplots A Barchart or barplot takes these frequencies, and draws bars along the X-axis where the height of the bars is determined by the frequencies seen in the table. 2.3.2.1 base To create a barplot/barchart in base graphics requires the data to be in summarized in a table form first. Then the result of the table is plotted. The first argument is the table to be plotted, the main argument controls the title. dc &lt;- table(dsmall$cut) barplot(dc, main=&quot;Barchart using base graphics&quot;) 2.3.2.2 ggplot The geometry needed to draw a barchart in ggplot is geom_bar(). ggplot(dsmall, aes(x=cut)) + geom_bar() 2.3.2.3 pretty The biggest addition to a barchart is the numbers on top of the bars. This isn’t mandatory, but it does make it nice. ggplot(dsmall, aes(x=cut)) + theme_bw() + geom_bar(aes(y = ..count..)) + ggtitle(&quot;Frequnency of diamonds by cut type&quot;) + geom_text(aes(y=..count.. + 10, label=..count..), stat=&#39;count&#39;, size = 5) 2.3.2.4 Plotting Proportions Often you don’t want to compare counts but percents. To accomplish this, we have to aggregate the data to calculate the proportions first, then plot the aggregated data using geom_col to create the columns. cut.props &lt;- data.frame(prop.table(table(dsmall$cut))) cut.props # what does this data look like? ## Var1 Freq ## 1 Fair 0.027 ## 2 Good 0.083 ## 3 Very Good 0.226 ## 4 Premium 0.277 ## 5 Ideal 0.387 ggplot(cut.props, aes(x=Var1, y=Freq)) + geom_col() + ylab(&quot;Proportion&quot;) + xlab(&quot;Cut type&quot;) + ggtitle(&quot;Proportion of diamonds by cut type&quot;) 2.3.3 Cleveland Dot Plots Another way to visualize categorical data that takes up less ink than bars is a Cleveland dot plot. Here again we are plotting summary data instead of the raw data. This uses a new geom_segment that draws the lines from x=0 to the dot, and that it should be placed on the y-axis at the value of Freq. ggplot(cut.props, aes(x=Freq, y=Freq)) + geom_point(size = 3) + xlab(&quot;Proportion of diamonds&quot;) + theme_bw() + ylab(&quot;Cut Type&quot;) + geom_segment(aes(yend=Freq), xend=0, color=&#39;grey50&#39;) 2.3.4 Pie Chart Just like barplot(), pie() takes a table object as it’s argument. 2.3.4.1 base dc &lt;- table(dsmall$cut) pie(dc) Pie charts are my least favorite plotting type. Human eyeballs can’t distinguish between angles as well as we can with heights. A mandatory piece needed to make the wedges readable is to add the percentages of each wedge. pie(dc, labels = paste0(names(dc), &#39; (&#39;, prop.table(dc)*100, &quot;%)&quot;)) 2.3.4.2 ggplot And here I thought pie charts couldn’t get worse… i’m not a fan at all of the ggplot version. So i’m not even going to show it. Here’s a link to another great tutorial that does show you how to make one. http://www.sthda.com/english/wiki/ggplot2-pie-chart-quick-start-guide-r-software-and-data-visualization 2.3.5 Waffle Chart This type of chart is not natively found in the ggplot2 package, but it’s own waffle package. These are great for infographics. Reference: https://www.r-bloggers.com/making-waffle-charts-in-r-with-the-new-waffle-package/ library(waffle) waffle(dc/10, rows=5, size=0.5, title=&quot;Cut quality of diamond&quot;, xlab=&quot;1 square == 10 diamonds&quot;) "],
["univariate-continuous-variable.html", "2.4 Univariate Continuous variable", " 2.4 Univariate Continuous variable Here we can look at the price, carat, and depth of the diamonds. 2.4.1 Dotplot plot(dsmall$depth) The base function plot() creates a dotplot for a continuous variable. The value of the variable is plotted on the y axis, and the index, or row number, is plotted on the x axis. This gives you a nice, quick way to see the values of the data. Often you are not interested in the individual values of each data point, but the distribution of the data. In other words, where is the majority of the data? Does it look symmetric around some central point? Around what values do the bulk of the data lie? 2.4.2 Histograms Rather than showing the value of each observation, we prefer to think of the value as belonging to a . The height of the bars in a histogram display the frequency of values that fall into those of those bins. For example if we cut the poverty rates into 7 bins of equal width, the frequency table would look like this: table(cut(dsmall$depth, 7)) ## ## (54.7,56.9] (56.9,59] (59,61.2] (61.2,63.3] (63.3,65.5] (65.5,67.6] ## 3 35 222 654 72 10 ## (67.6,69.8] ## 4 In a histogram, the binned counts are plotted as bars into a histogram. Note that the x-axis is continuous, so the bars touch. This is unlike the barchart that has a categorical x-axis, and vertical bars that are separated. 2.4.2.1 base You can make a histogram in base graphics super easy. hist(dsmall$depth) And it doesn’t take too much to clean it up. Here you can specify the number of bins by specifying how many breaks should be made in the data (the number of breaks controls the number of bins, and bin width) and use col for the fill color. hist(dsmall$depth, xlab=&quot;depth&quot;, main=&quot;Histogram of diamond depth&quot;, col=&quot;cyan&quot;, breaks=20) 2.4.2.2 ggplot ggplot(dsmall, aes(x=depth)) + geom_histogram(binwidth = 2.2) The binwidth here is set by looking at the cut points above that were used to create 7 bins. Notice that darkgrey is the default fill color, but makes it hard to differentiate between the bars. So we’ll make the outline black using colour, and fill the bars with white. ggplot(dsmall, aes(x=depth)) + geom_histogram(colour=&quot;black&quot;, fill=&quot;white&quot;) + ggtitle(&quot;Distribution of diamond depth&quot;) Note I did not specify the binwidth argument here. The size of the bins can hide features from your graph, the default value for ggplot2 is range/30 and usually is a good choice. 2.4.3 Density plots To get a better idea of the true shape of the distribution we can “smooth” out the bins and create what’s called a density plot or curve. Notice that the shape of this distribution curve is much more… “wigglier” than the histogram may have implied. 2.4.3.1 graphics plot(density(dsmall$depth)) Awesome title huh? (NOT) 2.4.3.2 ggplot2 ggplot(dsmall, aes(x=depth)) + geom_density() 2.4.4 Histograms + density Often is is more helpful to have the density (or kernel density) plot on top of a histogram plot. 2.4.4.1 Base Since the height of the bars in a histogram default to showing the frequency of records in the data set within that bin, we need to 1) scale the height so that it’s a relative frequency, and then use the lines() function to add a density() line on top. hist(dsmall$depth, prob=TRUE) lines(density(dsmall$depth), col=&quot;blue&quot;) 2.4.4.2 ggplot The syntax starts the same, we’ll add a new geom, geom_density and color the line blue. Then we add the histogram geom using geom_histogram but must specify that the y axis should be on the density, not frequency, scale. Note that this has to go inside the aesthetic statement aes(). I’m also going to get rid of the fill by using NA so it doesn’t plot over the density line. ggplot(dsmall, aes(x=depth)) + geom_density(col=&quot;blue&quot;) + geom_histogram(aes(y=..density..), colour=&quot;black&quot;, fill=NA) 2.4.5 Boxplots Another very common way to visualize the distribution of a continuous variable is using a boxplot. Boxplots are useful for quickly identifying where the bulk of your data lie. R specifically draws a “modified” boxplot where values that are considered outliers are plotted as dots. 2.4.5.1 base boxplot(dsmall$depth) Notice that the only axis labeled is the y=axis. Like a dotplot the x axis, or “width”, of the boxplot is meaningless here. We can make the axis more readable by flipping the plot on it’s side. boxplot(dsmall$depth, horizontal = TRUE, main=&quot;Distribution of diamond prices&quot;, xlab=&quot;Dollars&quot;) Horizontal is a bit easier to read in my opinion. 2.4.5.2 ggplot What about ggplot? ggplot doesn’t really like to do univariate boxplots. We can get around that by specifying that we want the box placed at a specific x value. ggplot(dsmall, aes(x=1, y=depth)) + geom_boxplot() To flip it horizontal you may think to simply swap x and y? Good thinking. Of course it wouldn’t be that easy. So let’s just flip the whole darned plot on it’s coordinate axis. ggplot(dsmall, aes(x=1, y=depth)) + geom_boxplot() + coord_flip() 2.4.6 Violin plots ggplot(dsmall, aes(x=1, y=depth)) + geom_violin() 2.4.7 Boxplot + Violin plots Overlaying a boxplot and a violin plot serves a similar purpose to Histograms + Density plots. ggplot(dsmall, aes(x=1, y=depth)) + geom_violin() + geom_boxplot() Better appearance - different levels of transparency of the box and violin. ggplot(dsmall, aes(x=1, y=depth)) + xlab(&quot;&quot;) + theme_bw() + geom_violin(fill=&quot;blue&quot;, alpha=.1) + geom_boxplot(fill=&quot;blue&quot;, alpha=.5, width=.2) + theme(axis.title.x=element_blank(), axis.text.x=element_blank(), axis.ticks.x=element_blank()) "],
["normal-qq-plots.html", "2.5 Normal QQ plots", " 2.5 Normal QQ plots The last useful plot that we will do on a single continuous variable is to assess the normality of the distribution. Basically how close the data follows a normal distribution. 2.5.0.1 base qqnorm(dsmall$price) qqline(dsmall$price, col=&quot;red&quot;) The line I make red because it is a reference line. The closer the points are to following this line, the more “normal” the shape of the distribution is. Price has some pretty strong deviation away from that line. Below I have plotted what a normal distribution looks like as an example of a “perfect” fit. z &lt;- rnorm(1000) qqnorm(z) qqline(z, col=&quot;blue&quot;) 2.5.0.2 ggplot qq (or qnorm) plots specifically plot the data against a theoretical distribution. That means in the aes() aesthetic argument we don’t specify either x or y, but instead the sample= is the variable we want to plot. ggplot(dsmall, aes(sample=price)) + stat_qq() Additional references on making qqplots in ggplot: http://www.sthda.com/english/wiki/ggplot2-qq-plot-quantile-quantile-graph-quick-start-guide-r-software-and-data-visualization "],
["categorical-v-categorical.html", "2.6 Categorical v. Categorical", " 2.6 Categorical v. Categorical 2.6.1 Two-way Tables Cross-tabs, cross-tabulations and two-way tables (all the same thing, different names) can be created by using the table() function. 2.6.1.1 Frequency table The frequency table is constructed using the table() function. table(dsmall$cut, dsmall$color) ## ## D E F G H I J ## Fair 4 5 4 3 10 1 0 ## Good 13 6 19 16 10 13 6 ## Very Good 30 60 37 50 26 18 5 ## Premium 39 42 40 55 46 40 15 ## Ideal 63 69 52 77 65 40 21 There are 4 Fair diamonds with color D, and 21 Ideal quality diamonds with color J. 2.6.1.2 Cell proportions Wrapping prop.table() around a table gives you the cell proportions. prop.table(table(dsmall$cut, dsmall$color)) ## ## D E F G H I J ## Fair 0.004 0.005 0.004 0.003 0.010 0.001 0.000 ## Good 0.013 0.006 0.019 0.016 0.010 0.013 0.006 ## Very Good 0.030 0.060 0.037 0.050 0.026 0.018 0.005 ## Premium 0.039 0.042 0.040 0.055 0.046 0.040 0.015 ## Ideal 0.063 0.069 0.052 0.077 0.065 0.040 0.021 0.4% of all diamonds are D color and Fair cut, 2.1% are J color and Ideal cut. 2.6.1.3 Row proportions To get the row proportions, you specify margin=1. The percentages now add up to 1 across the rows. round(prop.table(table(dsmall$cut, dsmall$color), margin=1),3) ## ## D E F G H I J ## Fair 0.148 0.185 0.148 0.111 0.370 0.037 0.000 ## Good 0.157 0.072 0.229 0.193 0.120 0.157 0.072 ## Very Good 0.133 0.265 0.164 0.221 0.115 0.080 0.022 ## Premium 0.141 0.152 0.144 0.199 0.166 0.144 0.054 ## Ideal 0.163 0.178 0.134 0.199 0.168 0.103 0.054 14.8% of all Fair quality diamonds are color D. 5.4% of all Ideal quality diamonds have color J. 2.6.1.4 Column proportions To get the column proportions, you specify margin=2. The percentages now add up to 1 down the columns. round(prop.table(table(dsmall$cut, dsmall$color), margin=2),3) ## ## D E F G H I J ## Fair 0.027 0.027 0.026 0.015 0.064 0.009 0.000 ## Good 0.087 0.033 0.125 0.080 0.064 0.116 0.128 ## Very Good 0.201 0.330 0.243 0.249 0.166 0.161 0.106 ## Premium 0.262 0.231 0.263 0.274 0.293 0.357 0.319 ## Ideal 0.423 0.379 0.342 0.383 0.414 0.357 0.447 2.7% of all D color diamonds are of Fair quality. 44.7% of all J color diamonds are of Ideal quality. 2.6.2 Grouped bar charts To compare proportions of one categorical variable within the same level of another, is to use grouped barcharts. 2.6.2.1 base As before, the object to be plotted needs to be the result of a table. cc &lt;- table(dsmall$cut, dsmall$color) barplot(cc) Stacked bars can be difficult to interpret, and very difficult to compare values between groups. A side by side barchart is preferable. The beside=TRUE is what controls the placement of the bars. barplot(cc, main=&quot;quick side by side barchart using base graphics&quot;, beside=TRUE) Great, but what do the colors represent? We need to add a legend. And i’m going to customize the colors. barplot(cc, main=&quot;quick side by side barchart using base graphics&quot;, beside=TRUE, col=rainbow(5), legend=rownames(cc)) For more than 2 colors I do not recommend choosing the colors yourself. I know little about color theory so I use the built-in color palettes. Here is a great cheatsheet about using color palettes. 2.6.2.2 ggplot Again plot the cut on the x axis, but then fill using the second categorical variable. This has the effect of visualizing the row percents from the table above. The percent of color, within each type of cut. ggplot(dsmall, aes(x=cut, fill=color)) + geom_bar() Again the default is a stacked barchart. So we just specify position=dodge to put the bars side by side. ggplot(dsmall, aes(x=cut, fill=color)) + geom_bar(position = &quot;dodge&quot;) And look, an automatic legend. What if I wanted to better compare cut within color group? This is the column percentages. Just switch which variable is the x axis and which one is used to fill the colors! ggplot(dsmall, aes(x=color, fill=cut)) + geom_bar(position = &quot;dodge&quot;) And this easy change is why we love ggplot2. 2.6.3 Grouped bar charts with percentages Not as easy as one would hope, but the solution is to calculate the desired percentages first and then plot the summary data using either geom_bar(stat='identity') or geom_col(). calc.props &lt;- diamonds %&gt;% group_by(color, cut) %&gt;% summarise(count=n()) %&gt;% mutate(pct=round(count/sum(count),3)) calc.props ## # A tibble: 35 x 4 ## # Groups: color [7] ## color cut count pct ## &lt;ord&gt; &lt;ord&gt; &lt;int&gt; &lt;dbl&gt; ## 1 D Fair 163 0.024 ## 2 D Good 662 0.098 ## 3 D Very Good 1513 0.223 ## 4 D Premium 1603 0.237 ## 5 D Ideal 2834 0.418 ## 6 E Fair 224 0.023 ## 7 E Good 933 0.095 ## 8 E Very Good 2400 0.245 ## 9 E Premium 2337 0.239 ## 10 E Ideal 3903 0.398 ## # ... with 25 more rows Since we’re plotting summary data, the height of the bars is specified using y=pct. ggplot(calc.props, aes(x=color, fill=cut, y=pct)) + geom_col(position=&quot;dodge&quot;) + theme_bw() Now set some options to the y axis using scale_y_continuous() to make the graph more accurate and readable. The labels=percent comes from the scales package. library(scales) ggplot(calc.props, aes(x=color, fill=cut, y=pct)) + geom_col(position=&quot;dodge&quot;) + theme_bw() + scale_y_continuous(limits=c(0,1), labels=percent) 2.6.4 Mosaic plots But what if you want to know how two categorical variables are related and you don’t want to look at two different barplots? Mosaic plots are a way to visualize the proportions in a table. So here’s the two-way table we’ll be plotting. table(dsmall$cut, dsmall$color) ## ## D E F G H I J ## Fair 4 5 4 3 10 1 0 ## Good 13 6 19 16 10 13 6 ## Very Good 30 60 37 50 26 18 5 ## Premium 39 42 40 55 46 40 15 ## Ideal 63 69 52 77 65 40 21 The syntax for a mosaic plot uses model notation, which is basically y ~ x where the ~ is read as “twiddle” or “tilde”. It’s to the left of your 1 key. mosaicplot(cut~color, data=dsmall) Helpful, ish. Here are two very useful options. In reverse obviousness, color applies shades of gray to one of the factor levels, and shade applies a color gradient scale to the cells in order of what is less than expected (red) to what is more than expected (blue) if these two factors were completely independent. par(mfrow=c(1,2)) # display the plots in 1 row and 2 columns mosaicplot(cut~color, data=dsmall, color=TRUE) mosaicplot(cut~color, data=dsmall, shade=TRUE) For example, there are fewer ‘Very Good’ cut diamonds that are color ‘G’, and fewer ‘Premium’ cut diamonds that are color ‘H’. As you can see, knowing what your data means when trying to interpret what the plots are telling you is essential. That’s about all the ways you can plot categorical variables. If you are wondering why there was no 3D barcharts demonstrated see here, here, and here for other ways you can really screw up your visualization. "],
["continuous-v-continuous.html", "2.7 Continuous v. Continuous", " 2.7 Continuous v. Continuous 2.7.1 Scatterplot The most common method of visualizing the relationship between two continuous variables is by using a scatterplot. 2.7.1.1 base Back to the plot() command. Here we use model notation again, so it’s \\(y~x\\). plot(price~carat, data=dsmall) Looks like for the most part as the carat value increases so does price. That makes sense. 2.7.1.2 ggplot With ggplot we specify both the x and y variables, and add a point. ggplot(dsmall, aes(x=carat, y=price)) + geom_point() "],
["scatterplot-matrix.html", "2.8 Scatterplot matrix", " 2.8 Scatterplot matrix A scatterplot matrix allows you to look at the bivariate comparison of multiple pairs of variables simultaneously. First we need to trim down the data set to only include the variables we want to plot, then we use the pairs() function. c.vars &lt;- dsmall[,c(&#39;carat&#39;, &#39;depth&#39;, &#39;price&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;)] pairs(c.vars) We can see price has a non-linear relationship with X, Y and Z and x &amp; y have a near perfect linear relationship. Other Resources * http://www.statmethods.net/graphs/scatterplot.html * https://www.r-bloggers.com/scatterplot-matrices/ 2.8.1 Adding lines to the scatterplots Two most common trend lines added to a scatterplots are the “best fit” straight line and the “lowess” smoother line. 2.8.1.1 base The best fit line (in blue) gets added by using the abline() function wrapped around the linear model function lm(). Note it uses the same model notation syntax and the data= statement as the plot() function does. The lowess line is added using the lines() function, but the lowess() function itself doesn’t allow for the data= statement so we have to use $ sign notation. plot(price~carat, data=dsmall) abline(lm(price~carat, data=dsmall), col=&quot;blue&quot;) lines(lowess(dsmall$price~dsmall$carat), col=&quot;red&quot;) 2.8.1.2 ggplot With ggplot, we just add a geom_smooth() layer. ggplot(dsmall, aes(x=carat, y=price)) + geom_point() + geom_smooth() Here the point-wise confidence interval for this lowess line is shown in grey. If you want to turn the confidence interval off, use se=FALSE. Also notice that the smoothing geom uses a different function or window than the lowess function used in base graphics. Here it is again using the ggplot plotting function and adding another geom_smooth() layer for the lm (linear model) line in blue, and the lowess line (by not specifying a method) in red. ggplot(dsmall, aes(x=carat, y=price)) + geom_point() + geom_smooth(se=FALSE, method=&quot;lm&quot;, color=&quot;blue&quot;) + geom_smooth(se=FALSE, color=&quot;red&quot;) "],
["line-plots.html", "2.9 Line plots", " 2.9 Line plots Line plots connect each dot with a straight line. We saw earlier that carat and price seemed possibly linear. Let see how the average price changes with carat. library(dplyr) price.per.carat &lt;- dsmall %&gt;% group_by(carat) %&gt;% summarise(mean = mean(price)) 2.9.1 base For base graphics, type=‘b’ means both points and lines, ‘l’ gives you just lines and ‘p’ gives you only points. You can find more plotting character options under ?pch. plot(mean~carat, data=price.per.carat, type=&#39;l&#39;) 2.9.2 ggplot With ggplot we specify that we want a line geometry only. ggplot(price.per.carat, aes(x=carat, y=mean)) + geom_line() How does this relationship change with cut of the diamond? First lets get the average price per combination of carat and cut. ppc2 &lt;- dsmall %&gt;% group_by(cut, carat) %&gt;% summarise(mean = mean(price)) 2.9.2.1 base This plot can be created in base graphics, but it takes an advanced knowledge of the graphics system to do so. So I do not show it here. 2.9.2.2 ggplot This is where ggplot starts to excel in it’s ease of creating more complex plots. All we have to do is specify that we want the lines colored by the cut variable. ggplot(ppc2, aes(x=carat, y=mean, col=cut)) + geom_line() And we get one line per cut. "],
["continuous-v-categorical.html", "2.10 Continuous v. Categorical", " 2.10 Continuous v. Categorical Create an appropriate plot for a continuous variable, and plot it for each level of the categorical variable. 2.10.1 Dotplot/strip chart Dotplots can be very useful when plotting dots against several categories. They can also be called stripcharts. 2.10.1.1 base stripchart(carat ~ cut, data=dsmall) Doesn’t look to pretty, but kinda gets the point across. Few fair quality diamonds in the data set, pretty spread out across the carat range except one high end outlier. 2.10.1.2 ggplot We can reproduce the same thing by plotting one continuous variable against one categorical variable, and adding a layer of points. I’d argue that horizontal looks better due to the axis-labels. a &lt;- ggplot(dsmall, aes(y=carat, x=cut)) + geom_point() b &lt;- ggplot(dsmall, aes(y=cut, x=carat)) + geom_point() grid.arrange(a, b, ncol=2) 2.10.2 Grouped boxplots 2.10.2.1 base Base graphics plots grouped boxplots with also just the addition of a twiddle (tilde) ~. Another example of where model notation works. boxplot(carat~color, data=dsmall) 2.10.2.2 ggplot A simple addition, just define your x and y accordingly. ggplot(dsmall, aes(x=color, y=carat, fill=color)) + geom_boxplot() 2.10.2.3 Adding violins Violin plots can be overlaid here as well. ggplot(dsmall, aes(x=color, y=carat, fill=color)) + geom_violin(alpha=.1) + geom_boxplot(alpha=.5, width=.2) 2.10.3 Grouped histograms 2.10.3.1 base There is no easy way to create grouped histograms in base graphics we will skip it. 2.10.3.2 ggplot By default ggplot wants to overlay all plots on the same grid. This doesn’t look to good with histograms. Instead you can overlay density plots a &lt;- ggplot(dsmall, aes(x=carat, fill=color)) + geom_histogram() b &lt;- ggplot(dsmall, aes(x=carat, fill=color)) + geom_density() grid.arrange(a,b, ncol=2) The solid fills are still difficult to read, so we can either turn down the alpha (turn up the transparency) or only color the lines and not the fill. c &lt;- ggplot(dsmall, aes(x=carat, fill=color)) + geom_density(alpha=.2) d &lt;- ggplot(dsmall, aes(x=carat, col=color)) + geom_density() grid.arrange(c,d, ncol=2) "],
["joy-plots-in-progress.html", "2.11 Joy plots (in progress)", " 2.11 Joy plots (in progress) Hot off the press, gaining instant popularity this summer (2017). They are a combination of a Cleveland dot plot and a density plot. See this blog post by Revolution Analytics in the meantime: http://blog.revolutionanalytics.com/2017/07/joyplots.html "],
["faceting-paneling.html", "2.12 Faceting / paneling", " 2.12 Faceting / paneling ggplot introduces yet another term called faceting. The definition is a particular aspect or feature of something, or one side of something many-sided, especially of a cut gem. Basically instead of plotting the grouped graphics on the same plotting area, we let each group have it’s own plot, or facet. We add a facet_wrap() and specify that we want to panel on the color group. Note the twiddle in front of color. ggplot(dsmall, aes(x=carat, fill=color)) + geom_density() + facet_wrap(~color) The grid placement can be semi-controlled by using the ncol argument in the facet_wrap() statement. ggplot(dsmall, aes(x=carat, fill=color)) + geom_density() + facet_wrap(~color, ncol=4) It is important to compare distributions across groups on the same scale, and our eyes can compare items vertically better than horizontally. So let’s force ncol=1. ggplot(dsmall, aes(x=carat, fill=color)) + geom_density() + facet_wrap(~color, ncol=1) "],
["other-ways-to-get-multiple-plots-per-window.html", "2.13 Other ways to get multiple plots per window", " 2.13 Other ways to get multiple plots per window 2.13.1 base I use par(mfrow=c(r,c)) for base graphics, where r is the number of rows and c the number of columns. par(mfrow=c(1,3)) plot(dsmall$carat) plot(dsmall$color) plot(dsmall$price ~ dsmall$carat) Other resources including learning about layouts. Multipanel plotting with base graphics http://seananderson.ca/courses/11-multipanel/multipanel.pdf 2.13.1.1 ggplot Use the grid.arrange function in the gridExtra package. I’ve done it several times above. You assign the output of a ggplot object to an object (here it’s plot1 and plot2). Then you use grid.arrange() to arrange them either side by side or top and bottom. a &lt;- ggplot(dsmall, aes(x=carat, fill=color)) + geom_density(alpha=.2) b &lt;- ggplot(dsmall, aes(x=carat, col=color)) + geom_density() grid.arrange(a,b, ncol=2) "],
["multivariate-2-variables.html", "2.14 Multivariate (2+ variables)", " 2.14 Multivariate (2+ variables) This is not much more complicated than taking an appropriate bivariate plot and adding a third variable through paneling, coloring, or changing a shape. This is trivial to do in ggplot, not trivial in base graphics. So I won’t show those examples. "],
["three-continuous.html", "2.15 Three continuous", " 2.15 Three continuous Continuous variables can also be mapped to the size of the point. Here I set the alpha on the points so we could see the overplotting (many points on a single spot). So the darker the spot the more data points on that spot. ggplot(dsmall, aes(x=carat, y=price, size=depth)) + geom_point(alpha=.2) "],
["two-categorical-and-one-continuous.html", "2.16 Two categorical and one continuous", " 2.16 Two categorical and one continuous This is very similar to side by side boxplots, one violin plot per cut, within each level of color. This is difficult to really see due to the large number of categories each factor has. ggplot(dsmall, aes(x=color, y=price, fill=cut)) + geom_violin() Best bet here would be to panel on color and change the x axis to cut. ggplot(dsmall, aes(x=cut, y=price, fill=cut)) + geom_violin() + facet_wrap(~color) "],
["two-continuous-and-one-categorical.html", "2.17 Two continuous and one categorical", " 2.17 Two continuous and one categorical a &lt;- ggplot(dsmall, aes(x=carat, y=price, color=cut)) + geom_point() + ggtitle(&quot;Colored by cut&quot;) d &lt;- ggplot(dsmall, aes(x=carat, y=price, color=cut)) + geom_point() + geom_smooth(se=FALSE) +ggtitle(&quot;Lowess line per cut&quot;) grid.arrange(a, d, nrow=1) Change the shape ggplot(dsmall, aes(x=carat, y=price, shape=cut)) + geom_point() + ggtitle(&quot;Shape by cut&quot;) Or we just panel by the third variable ggplot(dsmall, aes(x=carat, y=price)) + geom_point() + facet_wrap(~cut) "],
["paneling-on-two-variables.html", "2.18 Paneling on two variables", " 2.18 Paneling on two variables Who says we’re stuck with only faceting on one variable? A variant on facet_wrap is facet_grid. Here we can specify multiple variables to panel on. ggplot(dsmall, aes(x=carat, fill=color)) + geom_density() + facet_grid(cut~color) How about plotting price against caret, for all combinations of color and clarity, with the points further separated by cut? ggplot(dsmall, aes(x=carat, y=price, color=cut)) + geom_point() + facet_grid(clarity~color) And lastly let’s look back at how we can play with scatterplots of using a third categorical variable (using ggplot2 only). We can color the points by cut, ggplot(dsmall, aes(x=carat, y=price, color=cut)) + geom_point() We could add a smoothing lowess line for each cut separately, ggplot(dsmall, aes(x=carat, y=price, color=cut)) + geom_point() + geom_smooth(se=FALSE) We could change the color by clarity, and shape by cut. ggplot(dsmall, aes(x=carat, y=price, color=clarity, shape=cut)) + geom_point() That’s pretty hard to read. So note that just because you can change an aesthetic, doesn’t mean you should. And just because you can plot things on the same axis, doesn’t mean you have to. Before you share your plot with any other eyes, always take a step back and try to explain what it is telling you. If you have to take more than a minute to get to the point then it may be too complex and simpler graphics are likely warranted. "],
["troubleshooting.html", "2.19 Troubleshooting", " 2.19 Troubleshooting Problem: Missing data showing up as a category in ggplot? Get rid of that far right bar! ggplot(NCbirths, aes(x=marital)) + geom_bar() Solution: Use dplyr to select only the variables you are going to plot, then pipe in the na.omit() at the end. It will create a temporary data frame (e.g) plot.data that you then provide to ggplot(). plot.data &lt;- NCbirths %&gt;% select(marital) %&gt;% na.omit() ggplot(plot.data, aes(x=marital)) + geom_bar() Problem: Got numerical binary 0/1 data but want to plot it as categorical? &gt; Other related error messages: &gt; * Continuous x aesthetic – did you forget aes(group=…)? Consider a continuous variable for the number of characters in an email num_char, and a 0/1 binary variable spam. Solution: Create a second variable var_factor for plotting and keep the binary var as 0/1 for analysis. email$spam_cat &lt;- factor(email$spam, labels=c(&quot;Ham&quot;, &quot;Spam&quot;)) ggplot(email, aes(y=num_char, x=spam_cat)) + geom_boxplot() Problem: You want to change the legend title for a fill or color scale. Solution: Add the name= argument to whatever layer you added that created the legend. Here I speciefied a fill, and it was a discrete variable. So I use the scale_fill_discrete() layer. ggplot(email, aes(y=num_char, x=spam_cat, fill=spam_cat)) + geom_boxplot() + scale_fill_discrete(name=&quot;Ya like Spam?&quot;) Here, I colored the points by a discrete variable, so the layer is scale_color_discrete(). ggplot(email, aes(x=num_char, y=line_breaks, col=spam_cat)) + geom_point() + scale_color_discrete(name=&quot;Ya like Spam?&quot;) Problem: You want to add means to boxplots. Boxplots are great. Even better with violin overlays. Know what makes them even better than butter? Adding a point for the mean. stat_summary is the layer you want to add. Check out this stack overflow post for more context. ggplot(email, aes(x=spam_cat, y=num_char, fill=spam_cat)) + geom_boxplot() + stat_summary(fun.y=&quot;mean&quot;, geom=&quot;point&quot;, size=3, pch=17,color=&quot;blue&quot;) I suggest playing around with size and plotting character pch to get a feel for how these work. You can also look at ?pch (and scroll down in the help file) to see the 25 default plotting characters. "],
["but-what-about.html", "2.20 But what about…", " 2.20 But what about… Legend adjustment: remove it, move it to another side, rename it Custom specified colors and shapes Go here http://www.cookbook-r.com/Graphs/ for these. 2.20.1 Other plots not mentioned Heat maps https://www.r-bloggers.com/how-to-make-a-simple-heatmap-in-ggplot2/ Word clouds https://rpubs.com/brandonkopp/creating-word-clouds-in-r , simpler: http://dangoldin.com/2016/06/06/word-clouds-in-r/ Interactive plots - Look into plotly() and ggplotly() the circle type plots "],
["additional-resources.html", "2.21 Additional Resources", " 2.21 Additional Resources For any Google Search - be sure to limit searches to within the past year or so. R packages get updated very frequently, and many functions change or become obsolete. R Graphics: https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html The best book about using base graphics R Graphics Cookbook: http://www.cookbook-r.com/Graphs/ or http://amzn.com/1449316956 The best book for using ggplot2 STHDA: Statisical tools for high-throughput data analysis. http://www.sthda.com/english/ Quick-R: Basic Graphs Quick-R: ggplot2 Books ggplot2 http://ggplot2.org/book/ or http://amzn.com/0387981403 qplot http://ggplot2.org/book/qplot.pdf Help lists ggplot2 mailing list http://groups.google.com/group/ggplot2 stackoverflow http://stackoverflow.com/tags/ggplot2 Chico R users group "],
["select-analysis.html", "Chapter 3 Selecting Appropriate Analyses", " Chapter 3 Selecting Appropriate Analyses In Progress Considerations: Purpose of analysis. Types of variables in data set. Data used in analysis. Assumptions needed; satisfied? Choice of analyses is often arbitrary: consider several Example: 5 independent variables: 3 interval, 1 ordinal, 1 nominal 1 dependent variable: interval Analysis options Multiple regression: pretend independent ordinal variable is an interval variable use dummy (0 /1) variables for nominal variables Analysis of variance: categorize all independent variables Analysis of covariance: leave variables as is, check assumptions Logistic regression: Categorize dependent variable: high, low Survival analysis: IF dependent variable is time to an event Unsure? Do several and compare results. "],
["reg-intro.html", "Chapter 4 Introduction", " Chapter 4 Introduction The general purpose of regression is to learn more about the relationship between several independent or predictor variables and a quantitative dependent variable. Multiple regression procedures are very widely used in research. In general, this inferential tool allows us to ask (and hopefully answer) the general question “what is the best predictor of…”, and does “additional variable A” or “additional variable B” confound the relationship between my explanatory and response variable?” Educational researchers might want to learn about the best predictors of success in high-school. Sociologists may want to find out which of the multiple social indicators best predict whether or not a new immigrant group will adapt to their new country of residence. Biologists may want to find out which factors (i.e. temperature, barometric pressure, humidity, etc.) best predict caterpillar reproduction. This chapter starts by recapping notation and topics for simple linear regression, when there is only one predictor. Then we move into generalization of these concepts to many predictors, and model building topics such as stratification, interactions, and categorical predictors. "],
["simple-linear-regression.html", "Chapter 5 Simple Linear Regression", " Chapter 5 Simple Linear Regression The goal of linear regression is to Describe the relationship between an independent variable X and a continuous dependent variable \\(Y\\) as a straight line. The textbook discusses two cases: Fixed-\\(X\\): values of \\(X\\) are preselected by investigator Variable-\\(X\\): have random sample of \\((X,Y)\\) values Calculations are the same, Draw inferences regarding this relationship Predict value of \\(Y\\) for a given value of \\(X\\) "],
["mathmatical-model.html", "5.1 Mathmatical Model", " 5.1 Mathmatical Model The mean of \\(Y\\) values at any given \\(X\\) is \\(\\beta_{0} + \\beta_{1} X\\) The variance of \\(Y\\) values at any \\(X\\) is \\(\\sigma^2\\) (same for all X) \\(Y\\) values are normally distributed at any given \\(X\\) (need for inference) Figure 6.2 "],
["parameter-estimates.html", "5.2 Parameter Estimates", " 5.2 Parameter Estimates Estimate the slope \\(\\beta_{1}\\) and intercept \\(\\beta_{0}\\) using least-squares methods. The residual mean squared error (RMSE) is an estimate of the variance \\(s^{2}\\) Typically interested in inference on \\(\\beta_{1}\\) Assume no relationship between \\(X\\) and \\(Y\\) \\((H_{0}: \\beta_{1}=0)\\) until there is reason to believe there is one \\((H_{0}: \\beta_{1} \\neq 0)\\) "],
["interval-estimation.html", "5.3 Interval estimation", " 5.3 Interval estimation Everything is estimated with some degree of error Confidence intervals for the mean of \\(Y\\) Prediction intervals for an individual \\(Y\\) Which one is wider? Why? "],
["corelation-coefficient.html", "5.4 Corelation Coefficient", " 5.4 Corelation Coefficient The correlation coefficient \\(\\rho\\) measures the strength of association between \\(X\\) and \\(Y\\) in the population. \\(\\sigma^{2} = VAR(Y|X)\\) is the variance of \\(Y\\) for a specific \\(X\\). \\(\\sigma_{y}^{2} = VAR(Y)\\) is the variance of \\(Y\\) for all \\(X\\)’s. \\[ \\sigma^{2} = \\sigma_{y}^{2}(1-\\rho^{2})\\] \\[ \\rho^{2} = \\frac{\\sigma_{y}^{2} - \\sigma^{2}}{\\sigma_{y}^{2}}\\] \\(\\rho^{2}\\) = reduction in variance of Y associated with knowledge of X/original variance of Y Coefficient of Determiniation: \\(100\\rho^{2}\\) = % of variance of Y associated with X or explained by X Caution: association vs. causation. "],
["assumptions.html", "5.5 Assumptions", " 5.5 Assumptions Homogeneity of variance (same \\(\\sigma^{2}\\)) Not extremely serious Can use transformations to achieve it Graphical assessment: Plot the residuals against the x variable, add a lowess line. This assumption is upheld if there is no relationship/trend between the residuals and the predictor. Normal residuals Slight departures OK Can use transformations to achieve it Graphical assessment: normal qqplot of the model residuals. Randomness / Independence Very serious Can use hierarchical models for clustered samples No real good way to “test” for independence. Need to know how the sample was obtained. Linear relationship Slight departures OK Can use transformations to achieve it Graphical assessment: Simple scatterplot of \\(y\\) vs \\(x\\). Looking for linearity in the relationship. Should be done prior to any analysis. "],
["example.html", "5.6 Example", " 5.6 Example Using a cleaned version of the Lung function data set, lets explore the relationship between height and FEV for fathers in this data set. fev &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/Lung_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) qplot(y=FFEV1, x=FHEIGHT, geom=&quot;point&quot;, data=fev, xlab=&quot;Height&quot;, ylab=&quot;FEV1&quot;, main=&quot;Scatter Diagram with Regression (blue) and Lowess (red) Lines of FEV1 Versus Height for Fathers.&quot;) + geom_smooth(method=&quot;lm&quot;, se=FALSE, col=&quot;blue&quot;) + geom_smooth(se=FALSE, col=&quot;red&quot;) There does appear to be a tendency for taller men to have higher FEV1. Let’s fit a linear model and report the regression parameter estimates. model &lt;- lm(FFEV1 ~ FHEIGHT, data=fev) summary(model) ## ## Call: ## lm(formula = FFEV1 ~ FHEIGHT, data = fev) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.56688 -0.35290 0.04365 0.34149 1.42555 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -4.08670 1.15198 -3.548 0.000521 *** ## FHEIGHT 0.11811 0.01662 7.106 4.68e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5638 on 148 degrees of freedom ## Multiple R-squared: 0.2544, Adjusted R-squared: 0.2494 ## F-statistic: 50.5 on 1 and 148 DF, p-value: 4.677e-11 The least squares equation is \\(Y = -4.087 + 0.118X\\). confint(model) ## 2.5 % 97.5 % ## (Intercept) -6.36315502 -1.8102499 ## FHEIGHT 0.08526328 0.1509472 For ever inch taller a father is, his FEV1 measurement significantly increases by .12 (95%CI: .09, .15, p&lt;.0001). The correlation between FEV1 and height is \\(\\sqrt{.2544}\\) = 0.5. Lastly, check assumptions on the residuals to see if the model results are valid. Homogeneity of variance plot(model$residuals ~ fev$FHEIGHT) lines(lowess(model$residuals ~ fev$FHEIGHT), col=&quot;red&quot;) Normal residuals qqnorm(model$residuals) qqline(model$residuals, col=&quot;red&quot;) No major deviations away from what is expected. "],
["multiple-linear-regression.html", "Chapter 6 Multiple Linear Regression", " Chapter 6 Multiple Linear Regression Extends simple linear regression. Describes a linear relationship between a single continuous \\(Y\\) variable, and several \\(X\\) variables. Predicts \\(Y\\) from \\(X_{1}, X_{2}, \\ldots , X_{P}\\). Now it’s no longer a 2D regression line, but a \\(p\\) dimensional regression plane. "],
["types-of-x-variables.html", "6.1 Types of X variables", " 6.1 Types of X variables Fixed: The levels of \\(X\\) are selected in advance with the intent to measure the affect on an outcome \\(Y\\). Variable: Random sample of individuals from the population is taken and \\(X\\) and \\(Y\\) are measured on each individual. X’s can be continuous or discrete (categorical) X’s can be transformations of other X’s, e.g., \\(log(x), x^{2}\\). "],
["mathematical-model.html", "6.2 Mathematical Model", " 6.2 Mathematical Model \\[ y_{i} = \\beta_{0} + \\beta_{1}x_{1i} + \\ldots + \\beta_{p}x_{pi} + \\epsilon_{i}\\] The assumptions on the residuals \\(\\epsilon_{i}\\) still hold: They have mean zero They are homoscedastic, that is all have the same finite variance: \\(Var(\\epsilon_{i})=\\sigma^{2}&lt;\\infty\\) Distinct error terms are uncorrelated: (Independent) \\(\\text{Cov}(\\epsilon_{i},\\epsilon_{j})=0,\\forall i\\neq j.\\) The regression model relates \\(y\\) to a function of \\(\\textbf{X}\\) and \\(\\mathbf{\\beta}\\), where \\(\\textbf{X}\\) is a \\(nxp\\) matrix of \\(p\\) covariates on \\(n\\) observations and \\(\\mathbf{\\beta}\\) is a length \\(p\\) vector of regression coefficients. In matrix notation this looks like: \\[ \\textbf{y} = \\textbf{X} \\mathbf{\\beta} + \\mathbf{\\epsilon} \\] "],
["parameter-estimation.html", "6.3 Parameter Estimation", " 6.3 Parameter Estimation The goal of regression analysis is to minimize the residual error. That is, to minimize the difference between the value of the dependent variable predicted by the model and the true value of the dependent variable. \\[ \\epsilon_{i} = \\hat{y_{i}} - y_{i}\\] The method of Least Squares accomplishes this by finding parameter estimates \\(\\beta_{0}\\) and \\(\\beta_{1}\\) that minimized the sum of the squared residuals: \\[ \\sum_{i=1}^{n} \\epsilon_{i} \\] For simple linear regression the regression coefficient estimates that minimize the sum of squared errors can be calculated as: \\[ \\hat{\\beta_{0}} = \\bar{y} - \\hat{\\beta_{1}}\\bar{x} \\quad \\mbox{ and } \\quad \\hat{\\beta_{1}} = r\\frac{s_{y}}{s_{x}} \\] For multiple linear regression, the fitted values \\(\\hat{y_{i}}\\) are calculated as the linear combination of x’s and \\(\\beta\\)’s, \\(\\sum_{i=1}^{p}X_{ij}\\beta_{j}\\). The sum of the squared residual errors (the distance between the observed point \\(y_{i}\\) and the fitted value) now has the following form: \\[ \\sum_{i=1}^{n} |y_{i} - \\sum_{i=1}^{p}X_{ij}\\beta_{j}|^{2}\\] Or in matrix notation \\[ || \\mathbf{y} - \\mathbf{X}\\mathbf{\\beta} ||^{2} \\] The details of methods to calculate the Least Squares estimate of \\(\\beta\\)’s is left to a course in mathematical statistics. "],
["example-1.html", "6.4 Example", " 6.4 Example The analysis in example (???) concluded that FEV1 in fathers significantly increases by 0.12 (95% CI:0.09, 0.15) liters per additional inch in height (p&lt;.0001). Looking at the multiple \\(R^{2}\\) (correlation of determination), this simple model explains 25% of the variance seen in the outcome \\(y\\). However, FEV tends to decrease with age for adults, so we should be able to predict it better if we use both height and age as independent variables in a multiple regression equation. What direction do you expect the slope coefficient for age to be? For height? Fitting a regression model in R with more than 1 predictor is done by adding each variable to the right hand side of the model notation connected with a +. mv_model &lt;- lm(FFEV1 ~ FAGE + FHEIGHT, data=fev) summary(mv_model) ## ## Call: ## lm(formula = FFEV1 ~ FAGE + FHEIGHT, data = fev) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.34708 -0.34142 0.00917 0.37174 1.41853 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2.760747 1.137746 -2.427 0.0165 * ## FAGE -0.026639 0.006369 -4.183 4.93e-05 *** ## FHEIGHT 0.114397 0.015789 7.245 2.25e-11 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.5348 on 147 degrees of freedom ## Multiple R-squared: 0.3337, Adjusted R-squared: 0.3247 ## F-statistic: 36.81 on 2 and 147 DF, p-value: 1.094e-13 confint(mv_model) ## 2.5 % 97.5 % ## (Intercept) -5.00919751 -0.51229620 ## FAGE -0.03922545 -0.01405323 ## FHEIGHT 0.08319434 0.14559974 Holding height constant, a father who is one year older is expected to have a FEV value 0.03 (0.01, 0.04) liters less than another man (p&lt;.0001). Holding age constant, a father who is 1cm taller than another man is expected to have a FEV value of 0.11 (.08, 0.15) liter greater than the other man (p&lt;.0001). For the model that includes age, the coefficient for height is now 0.11, which is interpreted as the rate of change of FEV1 as a function of height after adjusting for age. This is also called the partial regression coefficient of FEV1 on height after adjusting for age. Both height and age are significantly associated with FEV in fathers (p&lt;.0001 each). "],
["model-diagnostics.html", "6.5 Model Diagnostics", " 6.5 Model Diagnostics The same set of regression diagnostics can be examined to identify any potential influential points, outliers or other problems with the linear model. par(mfrow=c(2,2)) plot(mv_model) "],
["multicollinearity.html", "6.6 Multicollinearity", " 6.6 Multicollinearity Occurs when some of the X variables are highly intercorrelated. Affects estimates and their SE’s (p. 143) Look at tolerance, and its inverse, the Variance Inflation Factor (VIF) Need tolerance &lt; 0.01, or VIF &gt; 100. car::vif(mv_model) ## FAGE FHEIGHT ## 1.003163 1.003163 tolerance = 1/car::vif(mv_model) tolerance ## FAGE FHEIGHT ## 0.9968473 0.9968473 Solution: use variable selection to delete some X variables. Alternatively, use dimension reduction techniques such as Principal Components "],
["what-to-watch-out-for.html", "6.7 What to watch out for", " 6.7 What to watch out for Representative sample Range of prediction should match observed range of X in sample Use of nominal or ordinal, rather than interval or ratio data Errors-in-variables Correlation does not imply causation Violation of assumptions Influential points Appropriate model Multicollinearity "],
["model-building.html", "Chapter 7 Model Building", " Chapter 7 Model Building Model building methods are used mainly in exploratory situations where many independent variables have been measured, but a final model explaining the dependent variable has not been reached. You want to build a model that contains enough covariates to explain the model well, but still be parsimonious such that the model is still interpretable. This chapter introduces different types of covariates that can be used, stratified models, confounding and moderation. We then conclude with measures of model fit and methods to compare between competing models. "],
["categorical-predictors.html", "7.1 Categorical Predictors", " 7.1 Categorical Predictors Let’s continue to model the length of the iris petal based on the length of the sepal, controlling for species. But here we’ll keep species as a categorical variable. What happens if we just put the variable in the model? summary(lm(Petal.Length ~ Sepal.Length + Species, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + Species, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.76390 -0.17875 0.00716 0.17461 0.79954 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.70234 0.23013 -7.397 1.01e-11 *** ## Sepal.Length 0.63211 0.04527 13.962 &lt; 2e-16 *** ## Speciesversicolor 2.21014 0.07047 31.362 &lt; 2e-16 *** ## Speciesvirginica 3.09000 0.09123 33.870 &lt; 2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2826 on 146 degrees of freedom ## Multiple R-squared: 0.9749, Adjusted R-squared: 0.9744 ## F-statistic: 1890 on 3 and 146 DF, p-value: &lt; 2.2e-16 Examine the coefficient names, Speciesversicolor and Speciesvirginica. R (and most software packages) automatically take a categorical variable and turn it into a series of binary indicator variables. Let’s look at what the software program does in the background. Below is a sample of the iris data. The first column shows the row number, specifically I am only showing 2 sample rows from each species. The second column is the value of the sepal length, the third is the binary indicator for if the iris is from species versicolor, next the binary indicator for if the iris is from species virginica, and lastly the species as a 3 level categorical variable (which is what we’re used to seeing at this point.) Sepal.Length Speciesversicolor Speciesvirginica Species 1 5.1 0 0 setosa 2 4.9 0 0 setosa 51 7 1 0 versicolor 52 6.4 1 0 versicolor 101 6.3 0 1 virginica 102 5.8 0 1 virginica 7.1.1 Factor variable coding Most commonly known as “Dummy coding”. Not an informative term to use. Better used term: Indicator variable Math notation: I(gender == “Female”). A.k.a reference coding For a nominal X with K categories, define K indicator variables. Choose a reference (referent) category: Leave it out Use remaining K-1 in the regression. Often, the largest category is chosen as the reference category. For the iris example, 2 indicator variables are created for versicolor and virginica. Interpreting the regression coefficients are going to be compared to the reference group. In this case, it is species setosa. The mathematical model is now written as follows, where \\(x_{1}\\) is Sepal Length, \\(x_{2}\\) is the indicator for versicolor, and \\(x_{3}\\) the indicator for virginica \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}x_{2i} + \\beta_{3}x_{3i}+ \\epsilon_{i}\\] Let’s look at the regression coefficients and their 95% confidence intervals from the main effects model again. main.eff.model &lt;- lm(Petal.Length ~ Sepal.Length + Species, data=iris) pander(main.eff.model) Fitting linear model: Petal.Length ~ Sepal.Length + Species Estimate Std. Error t value Pr(&gt;|t|) (Intercept) -1.702 0.2301 -7.397 1.005e-11 Sepal.Length 0.6321 0.04527 13.96 1.121e-28 Speciesversicolor 2.21 0.07047 31.36 9.646e-67 Speciesvirginica 3.09 0.09123 33.87 4.918e-71 pander(confint(main.eff.model)) 2.5 % 97.5 % (Intercept) -2.157 -1.248 Sepal.Length 0.5426 0.7216 Speciesversicolor 2.071 2.349 Speciesvirginica 2.91 3.27 In this main effects model, Species only changes the intercept. The effect of species is not multiplied by Sepal length. The interpretations are the following: \\(b_{1}\\): After controlling for species, Petal length significantly increases with the length of the sepal (0.63, 95% CI 0.54-0.72, p&lt;.0001). \\(b_{2}\\): Versicolor has on average 2.2cm longer petal lengths compared to setosa (95% CI 2.1-2.3, p&lt;.0001). \\(b_{3}\\): Virginica has on average 3.1cm longer petal lengths compared to setosa (95% CI 2.9-3.3, p&lt;.0001). 7.1.2 Wald test The Wald test is used for simultaneous tests of \\(Q\\) variables in a model Consider a model with \\(P\\) variables and you want to test if \\(Q\\) additional variables are useful. \\(H_{0}: Q\\) additional variables are useless, i.e., their \\(\\beta\\)’s all = 0 \\(H_{A}: Q\\) additional variables are useful The traditional test statistic that we’ve seen since Intro stats is \\(\\frac{\\hat{\\theta}-\\theta}{\\sqrt{Var(\\hat{\\theta})}}\\) The Wald test generalizes this test any linear combination of predictors. \\[ (R\\hat{\\theta}_{n}-r)^{&#39;}[R({\\hat{V}}_{n}/n)R^{&#39;}]^{-1} (R\\hat{\\theta}_{n}-r) \\quad \\xrightarrow{\\mathcal{D}} \\quad F(Q,n-P) \\] Where \\(\\mathbf{R}\\) is the vector of coefficients for the \\(\\beta\\), and \\(\\hat{V}_{n}\\) is a consistent estimator of the covariance matrix. Instead of a normal distribution, this test statistic has an \\(F\\) distribution with \\(Q\\) and \\(n-P\\) degrees of freedom. In the case where we’re testing \\(\\beta_{p}=\\beta_{q}=...=0\\), \\(\\mathbf{R}\\) is all 1’s. This can be done in R by using the regTermTest() function in the survey package. library(survey) regTermTest(main.eff.model, &quot;Species&quot;) ## Wald test for Species ## in lm(formula = Petal.Length ~ Sepal.Length + Species, data = iris) ## F = 624.9854 on 2 and 146 df: p= &lt; 2.22e-16 7.1.2.0.1 Example 1: Employment status on depression score Consider a model to predict depression using age, employment status and whether or not the person was chronically ill in the past year as covariates. This example uses the cleaned depression data set. depress &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;, header=TRUE,sep=&quot;\\t&quot;) full_model &lt;- lm(cesd ~ age + chronill + employ, data=depress) pander(summary(full_model)) Estimate Std. Error t value Pr(&gt;|t|) (Intercept) 11.48 1.502 7.646 3.191e-13 age -0.133 0.03514 -3.785 0.0001873 chronill 2.688 1.024 2.625 0.009121 employHouseperson 6.75 1.797 3.757 0.0002083 employIn School 1.967 5.995 0.328 0.7431 employOther 4.897 4.278 1.145 0.2533 employPT 3.259 1.472 2.214 0.02765 employRetired 3.233 1.886 1.714 0.08756 employUnemp 7.632 2.339 3.263 0.001238 Fitting linear model: cesd ~ age + chronill + employ Observations Residual Std. Error \\(R^2\\) Adjusted \\(R^2\\) 294 8.385 0.1217 0.09704 The results of this model show that age and chronic illness are statistically associated with CESD (each p&lt;.006). However employment status shows mixed results. Some employment statuses are significantly different from the reference group, some are not. So overall, is employment status associated with depression? Recall that employment is a categorical variable, and all the coefficient estimates shown are the effect of being in that income category has on depression compared to being employed full time. For example, the coefficient for PT employment is greater than zero, so they have a higher CESD score compared to someone who is fully employed. But what about employment status overall? Not all employment categories are significantly different from FT status. To test that employment status affects CESD we need to do a global test that all \\(\\beta\\)’s are 0. \\(H_{0}: \\beta_{3} = \\beta_{4} = \\beta_{5} = \\beta_{6} = \\beta_{7} = \\beta_{8} = 0\\) \\(H_{A}\\): At least one \\(\\beta_{j}\\) is not 0. regTermTest(full_model, &quot;employ&quot;) ## Wald test for employ ## in lm(formula = cesd ~ age + chronill + employ, data = depress) ## F = 4.153971 on 6 and 285 df: p= 0.0005092 Confirm that the degrees of freedom are correct. It should equal the # of categories in the variable you are testing, minus 1. Employment has 7 levels, so \\(df=6\\). Or equivalently, the degrees of freedom are the number of \\(beta\\)’s you are testing to be 0. The p-value of this Wald test is significant, thus employment significantly predicts CESD score. 7.1.2.1 Example 2: Blood Pressure load(url(&quot;https://norcalbiostat.netlify.com/data/addhealth_clean.Rdata&quot;)) addhealth$smoke &lt;- ifelse(addhealth$eversmoke_c==&quot;Smoker&quot;, 1, 0) Consider a logistic model on smoking status (0= never smoked, 1=has smoked) using gender, income, and blood pressure class (bp_class) as predictors. \\[ logit(Y) = \\beta_{0} + \\beta_{1}\\mbox{(female)} + \\beta_{2}\\mbox{(income)} + \\beta_{3}\\mbox{(Pre-HTN)} + \\beta_{4}\\mbox{(HTN-I)} + \\beta_{5}\\mbox{(HTN-II)} \\] bp.mod &lt;- glm(smoke ~ female_c + income + bp_class, data=addhealth, family=&#39;binomial&#39;) pander(summary(bp.mod)) Estimate Std. Error z value Pr(&gt;|z|) (Intercept) 1.046 0.1064 9.836 7.881e-23 female_cFemale -0.6182 0.07617 -8.117 4.798e-16 income -3.929e-06 1.411e-06 -2.785 0.005346 bp_classPre-HTN 0.07289 0.08206 0.8882 0.3745 bp_classHTN-I -0.02072 0.1093 -0.1895 0.8497 bp_classHTN-II 0.02736 0.1888 0.1449 0.8848 (Dispersion parameter for binomial family taken to be 1 ) Null deviance: 4853 on 3728 degrees of freedom Residual deviance: 4769 on 3723 degrees of freedom It is unlikely that blood pressure is associated with smoking status, all groups are not statistically significantly different from the reference group (all p-values are large). Let’s test that hypothesis formally using a Wald Test. regTermTest(bp.mod, &quot;bp_class&quot;) ## Wald test for bp_class ## in glm(formula = smoke ~ female_c + income + bp_class, family = &quot;binomial&quot;, ## data = addhealth) ## F = 0.428004 on 3 and 3723 df: p= 0.73294 The Wald Test has a large p-value of 0.73, thus blood pressure classification is not associated with smoking status. This means blood pressure classification should not be included in a model to explain smoking status. "],
["stratification.html", "7.2 Stratification", " 7.2 Stratification Stratified models examine the regression equations for each subgroup of the population and seeing if the relationship between the response and explanatory variables changed for at least one subgroup. Consider the relationship between the length of an iris petal, and the length of it’s sepal. Earlier we found that the iris species modified this relationship. Lets consider a binary indicator variable for species that groups veriscolor and virginica together. iris$setosa &lt;- ifelse(iris$Species==&quot;setosa&quot;, 1, 0) table(iris$setosa, iris$Species) ## ## setosa versicolor virginica ## 0 0 50 50 ## 1 50 0 0 Within the setosa species, there is little to no relationship between sepal and petal length. For the other two species, the relationship looks still significantly positive, but in the combined sample there appears to be a strong positive relationship (blue). ggplot(iris, aes(x=Sepal.Length, y=Petal.Length, col=as.factor(setosa))) + geom_point() + theme_bw() + theme(legend.position=&quot;top&quot;) + scale_color_manual(name=&quot;Species setosa&quot;, values=c(&quot;red&quot;, &quot;darkgreen&quot;)) + geom_smooth(se=FALSE, method=&quot;lm&quot;) + geom_smooth(aes(x=Sepal.Length, y=Petal.Length), col=&quot;blue&quot;, se=FALSE, method=&#39;lm&#39;) The mathematical model describing the relationship between Petal length (\\(Y\\)), and Sepal length (\\(X\\)), for species setosa (\\(s\\)) versus not-setosa (\\(n\\)), is written as follows: \\[ Y_{is} \\sim \\beta_{0s} + \\beta_{1s}*x_{i} + \\epsilon_{is} \\qquad \\epsilon_{is} \\sim \\mathcal{N}(0,\\sigma^{2}_{s})\\] \\[ Y_{in} \\sim \\beta_{0n} + \\beta_{1n}*x_{i} + \\epsilon_{in} \\qquad \\epsilon_{in} \\sim \\mathcal{N}(0,\\sigma^{2}_{n}) \\] In each model, the intercept, slope, and variance of the residuals can all be different. This is the unique and powerful feature of stratified models. The downside is that each model is only fit on the amount of data in that particular subset. Furthermore, each model has 3 parameters that need to be estimated: \\(\\beta_{0}, \\beta_{1}\\), and \\(\\sigma^{2}\\), for a total of 6 for the two models. The more parameters that need to be estimated, the more data we need. "],
["moderation.html", "7.3 Moderation", " 7.3 Moderation Moderation occurs when the relationship between two variables depends on a third variable. The third variable is referred to as the moderating variable or simply the moderator. The moderator affects the direction and/or strength of the relationship between the explanatory (\\(x\\)) and response (\\(y\\)) variable. This tends to be an important When testing a potential moderator, we are asking the question whether there is an association between two constructs, but separately for different subgroups within the sample. This is also called a stratified model, or a subgroup analysis. Here are 3 scenarios demonstrating how a third variable can modify the relationship between the original two variables. Scenario 1 - Significant relationship at bivariate level (saying expect the effect to exist in the entire population) then when test for moderation the third variable is a moderator if the strength (i.e., p-value is Non-Significant) of the relationship changes. Could just change strength for one level of third variable, not necessarily all levels of the third variable. Scenario 2 - Non-significant relationship at bivariate level (saying do not expect the effect to exist in the entire population) then when test for moderation the third variable is a moderator if the relationship becomes significant (saying expect to see it in at least one of the sub-groups or levels of third variable, but not in entire population because was not significant before tested for moderation). Could just become significant in one level of the third variable, not necessarily all levels of the third variable. Scenario 3 - Significant relationship at bivariate level (saying expect the effect to exist in the entire population) then when test for moderation the third variable is a moderator if the direction (i.e., means change order/direction) of the relationship changes. Could just change direction for one level of third variable, not necessarily all levels of the third variable. Recall that common analysis methods for analyzing bivariate relationships come in very few flavors: Correlation (Q~Q) Linear Regression (Q~Q) \\(\\chi^{2}\\) (C~C) ANOVA (Q~C) 7.3.1 Example 1: Sepal vs Petal Length We just got done looking at the relationship between the length of an iris’s Sepal, and the length (cm) of it’s petal. overall &lt;- ggplot(iris, aes(x=Sepal.Length, y=Petal.Length)) + geom_point() + geom_smooth(se=FALSE) + theme_bw() by_spec &lt;- ggplot(iris, aes(x=Sepal.Length, y=Petal.Length, col=Species)) + geom_point() + geom_smooth(se=FALSE) + theme_bw() + theme(legend.position=&quot;top&quot;) library(gridExtra) grid.arrange(overall, by_spec , ncol=2) Is the relationship between sepal length and petal length the same within each species? Let’s look at the correlation between these two continuous variables overall cor(iris$Sepal.Length, iris$Petal.Length) ## [1] 0.8717538 stratified by species by(iris, iris$Species, function(x) cor(x$Sepal.Length, x$Petal.Length)) ## iris$Species: setosa ## [1] 0.2671758 ## -------------------------------------------------------- ## iris$Species: versicolor ## [1] 0.754049 ## -------------------------------------------------------- ## iris$Species: virginica ## [1] 0.8642247 There is a strong, positive, linear relationship between the sepal length of the flower and the petal length when ignoring the species. The correlation coefficient \\(r\\) for virginica and veriscolor are similar to the overall \\(r\\) value, 0.86 and 0.75 respectively compared to 0.87. However the correlation between sepal and petal length for species setosa is only 0.26. The points are clearly clustered by species, the slope of the lowess line between virginica and versicolor appear similar in strength, whereas the slope of the line for setosa is closer to zero. This would imply that petal length for Setosa may not be affected by the length of the sepal. 7.3.2 Example 2: Simpson’s Paradox Sometimes moderating variables can result in what’s known as Simpson’s Paradox https://en.wikipedia.org/wiki/Simpson%27s_paradox "],
["interactions.html", "7.4 Interactions", " 7.4 Interactions If we care about how species changes the relationship between petal and sepal length, we can fit a model with an interaction between sepal length (\\(x_{1}\\)) and species. For this first example let \\(x_{2}\\) be an indicator for when species == setosa . Note that both main effects of sepal length, and setosa species are also included in the model. Interactions are mathematically represented as a multiplication between the two variables that are interacting. \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}x_{2i} + \\beta_{3}x_{1i}x_{2i}\\] Ifwe evaluate this model for both levels of \\(x_{2}\\), the resulting models are the same as the stratified models. When \\(x_{2} = 0\\), the record is on an iris not from the setosa species. \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}(0) + \\beta_{3}x_{1i}(0)\\] which simplifies to \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i}\\] When \\(x_{2} = 1\\), the record is on an iris of the setosa species. \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}(1) + \\beta_{3}x_{1i}(1)\\] which simplifies to \\[ Y_{i} \\sim (\\beta_{0} + \\beta_{2}) + (\\beta_{1} + \\beta_{3})x_{i}\\] Each subgroup model has a different intercept and slope, but we had to estimate 4 parameters in the interaction model, and 6 for the fully stratified model. Interactions are fit in R by simply multiplying * the two variables together in the model statement. summary(lm(Petal.Length ~ Sepal.Length + setosa + Sepal.Length*setosa, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + setosa + Sepal.Length * ## setosa, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.96754 -0.19948 -0.01386 0.22597 1.05479 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.55571 0.37509 -4.148 5.68e-05 *** ## Sepal.Length 1.03189 0.05957 17.322 &lt; 2e-16 *** ## setosa 2.35877 0.88266 2.672 0.00839 ** ## Sepal.Length:setosa -0.90026 0.17000 -5.296 4.28e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3929 on 146 degrees of freedom ## Multiple R-squared: 0.9515, Adjusted R-squared: 0.9505 ## F-statistic: 954.1 on 3 and 146 DF, p-value: &lt; 2.2e-16 The coefficient \\(b_{3}\\) for the interaction term is significant, confirming that species changes the relationship between sepal length and petal length. 7.4.1 Example summary(lm(Petal.Length ~ Sepal.Length + setosa + Sepal.Length*setosa, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + setosa + Sepal.Length * ## setosa, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.96754 -0.19948 -0.01386 0.22597 1.05479 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.55571 0.37509 -4.148 5.68e-05 *** ## Sepal.Length 1.03189 0.05957 17.322 &lt; 2e-16 *** ## setosa 2.35877 0.88266 2.672 0.00839 ** ## Sepal.Length:setosa -0.90026 0.17000 -5.296 4.28e-07 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3929 on 146 degrees of freedom ## Multiple R-squared: 0.9515, Adjusted R-squared: 0.9505 ## F-statistic: 954.1 on 3 and 146 DF, p-value: &lt; 2.2e-16 If \\(x_{2}=0\\), then the effect of \\(x_{1}\\) on \\(Y\\) simplifies to: \\(\\beta_{1}\\) \\(b_{1}\\) The effect of sepal length on petal length for non-setosa species of iris (setosa=0) For non-setosa species, the petal length increases 1.03cm for every additional cm of sepal length. If \\(x_{2}=1\\), then the effect of \\(x_{1}\\) on \\(Y\\) model simplifies to: \\(\\beta_{1} + \\beta_{3}\\) For setosa species, the petal length increases by 1.03-0.9=0.13 cm for every additional cm of sepal length. The main effects (\\(b_{1}\\), \\(b_{2}\\)) cannot be interpreted by themselves when there is an interaction in the model. Let’s up the game now and look at the full interaction model with a categorical version of species. Recall \\(x_{1}\\) is Sepal Length, \\(x_{2}\\) is the indicator for versicolor, and \\(x_{3}\\) the indicator for virginica . \\[ Y_{i} \\sim \\beta_{0} + \\beta_{1}x_{i} + \\beta_{2}x_{2i} + \\beta_{3}x_{3i} + \\beta_{4}x_{1i}x_{2i} + \\beta_{5}x_{1i}x_{3i}+\\epsilon_{i}\\] summary(lm(Petal.Length ~ Sepal.Length + Species + Sepal.Length*Species, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + Species + Sepal.Length * ## Species, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.68611 -0.13442 -0.00856 0.15966 0.79607 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 0.8031 0.5310 1.512 0.133 ## Sepal.Length 0.1316 0.1058 1.244 0.216 ## Speciesversicolor -0.6179 0.6837 -0.904 0.368 ## Speciesvirginica -0.1926 0.6578 -0.293 0.770 ## Sepal.Length:Speciesversicolor 0.5548 0.1281 4.330 2.78e-05 *** ## Sepal.Length:Speciesvirginica 0.6184 0.1210 5.111 1.00e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2611 on 144 degrees of freedom ## Multiple R-squared: 0.9789, Adjusted R-squared: 0.9781 ## F-statistic: 1333 on 5 and 144 DF, p-value: &lt; 2.2e-16 The slope of the relationship between sepal length and petal length is calculated as follows, for each species: setosa \\((x_{2}=0, x_{3}=0): b_{1}=0.13\\) versicolor \\((x_{2}=1, x_{3}=0): b_{1} + b_{2} + b_{4} = 0.13+0.55 = 0.68\\) virginica \\((x_{2}=0, x_{3}=1): b_{1} + b_{3} + b_{5} = 0.13+0.62 = 0.75\\) Compare this to the estimates gained from the stratified model: coef(lm(Petal.Length ~ Sepal.Length, data=subset(iris, Species==&quot;setosa&quot;))) ## (Intercept) Sepal.Length ## 0.8030518 0.1316317 coef(lm(Petal.Length ~ Sepal.Length, data=subset(iris, Species==&quot;versicolor&quot;))) ## (Intercept) Sepal.Length ## 0.1851155 0.6864698 coef(lm(Petal.Length ~ Sepal.Length, data=subset(iris, Species==&quot;virginica&quot;))) ## (Intercept) Sepal.Length ## 0.6104680 0.7500808 They’re the same! Proof that an interaction is equivalent to stratification. 7.4.2 Example What if we now wanted to include other predictors in the model? How does sepal length relate to petal length after controlling for petal width? We add the variable for petal width into the model summary(lm(Petal.Length ~ Sepal.Length + setosa + Sepal.Length*setosa + Petal.Width, data=iris)) ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length + setosa + Sepal.Length * ## setosa + Petal.Width, data = iris) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.83519 -0.18278 -0.01812 0.17004 1.06968 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.86850 0.27028 -3.213 0.00162 ** ## Sepal.Length 0.66181 0.05179 12.779 &lt; 2e-16 *** ## setosa 1.83713 0.62355 2.946 0.00375 ** ## Petal.Width 0.97269 0.07970 12.204 &lt; 2e-16 *** ## Sepal.Length:setosa -0.61106 0.12213 -5.003 1.61e-06 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.2769 on 145 degrees of freedom ## Multiple R-squared: 0.9761, Adjusted R-squared: 0.9754 ## F-statistic: 1478 on 4 and 145 DF, p-value: &lt; 2.2e-16 So far, petal width, and the combination of species and sepal length are both significantly associated with petal length. Note of caution: Stratification implies that the stratifying variable interacts with all other variables. So if we were to go back to the stratified model where we fit the model of petal length on sepal length AND petal width, stratified by species, we would be implying that species interacts with both sepal length and petal width. E.g. the following stratified model \\(Y = A + B + C + D + C*D\\), when D=1 \\(Y = A + B + C + D + C*D\\), when D=0 is the same as the following interaction model: \\(Y = A + B + C + D + A*D + B*D + C*D\\) "],
["confounding.html", "7.5 Confounding", " 7.5 Confounding One primary purpose of a multivariable model is to assess the relationship between a particular explanatory variable \\(x\\) and your response variable \\(y\\), after controlling for other factors. As we just discussed, those other factors (characteristics/variables) could also be explaining part of the variability seen in \\(y\\). If the relationship between \\(x_{1}\\) and \\(y\\) is bivariately significant, but then no longer significant once \\(x_{2}\\) has been added to the model, then \\(x_{2}\\) is said to explain, or confound, the relationship between \\(x_{1}\\) and \\(y\\). All the ways covariates can affect response variables Credit: A blog about statistical musings Easy to read short article from a Gastroenterology journal on how to control confounding effects by statistical analysis. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4017459/ "],
["variable-selection-process.html", "7.6 Variable Selection Process", " 7.6 Variable Selection Process We want to choose a set of independent variables that both will yield a good prediction using as few variables as possible. We also need to consider controlling for moderators and confounders. In many situations where regression is used, the investigator has strong justification for including certain variables in the model. previous studies accepted theory The investigator may have prior justification for using certain variables but may be open to suggestions for the remaining variables. The set of independent variables can be broken down into logical subsets The usual demographics are entered first (age, gender, ethnicity) A set of variables that other studies have shown to affect the dependent variable A third set of variables that could be associated but the relationship has not yet been examined. Partially model-driven regression analysis and partially an exploratory analysis. Automated versions of variable selection processes should not be used blindly. 7.6.1 Automated selection procedures Forward selection: X variables added one at a time until optimal model reached Backward elimination: X variables removed one at a time until optimal model reached Stepwise selection: Combination of forward and backward. “… perhaps the most serious source of error lies in letting statistical procedures make decisions for you.” “Don’t be too quick to turn on the computer. Bypassing the brain to compute by reflex is a sure recipe for disaster.” Good and Hardin, Common Errors in Statistics (and How to Avoid Them), p. 3, p. 152 Take home message: Don’t use these blindly. Stopping criteria and algorithm can be different for different software programs. Can reject perfectly plausible models from later consideration Hides relationships between variables (X3 is added and now X1 is no longer significant. X1 vs X3 should be looked at) 7.6.2 The lesser of three evils: Best Subsets (PMA5 Section 8.7) Select one X with highest simple \\(r\\) with Y Select two X’s with highest multiple \\(r\\) with Y Select three X’s with highest multiple \\(r\\) with Y etc. Compute adjusted R2, AIC or BIC each time. Compare and choose among the “best subsets” of various sizes. Ways to conduct best subsets regression in R: https://rstudio-pubs-static.s3.amazonaws.com/2897_9220b21cfc0c43a396ff9abf122bb351.html "],
["comparing-between-models.html", "7.7 Comparing between models", " 7.7 Comparing between models When working with multiple models, how do you choose the optimal model? How do we measure “optimal”? RMSE: Root Mean Squared Error How biased are the results? How ``far away&quot; are the estimates \\(\\hat{\\theta}\\) from the truth \\(\\theta\\)? \\[ \\sqrt{\\operatorname{MSE}(\\hat{\\theta})} = \\sqrt{\\operatorname{E}((\\hat{\\theta}-\\theta)^2)}. \\] Maximize the Likelihood function What is the likelihood that we observed the data \\(x\\), given parameter values \\(\\theta\\). \\[ \\mathcal{L}(\\theta \\mid x)=p_{\\theta }(x)=P_{\\theta }(X=x) \\] For strictly convenient mathematical matters, we tend to work with the log-likelihood (LL). Great because \\(log\\) is a monotonic increasing function, maximizing the LL = maximizing the likelihood function. We can compare between models using functions based off the LL. There are several measures we can use to compare between competing models. Multiple \\(R^{2}\\) If the model explains a large amount of variation in the outcome that’s good right? So we could consider using \\(R^{2}\\) as a selection criteria and trying to find the model that maximizes this value. The residual sum of squares (RSS in the book or SSE) can be written as \\(\\sum(Y-\\hat{Y})^{2}(1-R^{2})\\). Therefore minimizing the RSS is equivalent to maximizing the multiple correlation coefficient. Problem: The multiple \\(R^{2}\\) always increases as predictors are added to the model. - Ex. 1: N = 100, P = 1, E(\\(R^{2}\\)) = 0.01 - Ex. 2: N = 21, P = 10, E(\\(R^{2}\\)) = 0.5 Problem: \\(R^{2} = 1-\\frac{Model SS}{Total SS}\\) is biased: If population \\(R^{2}\\) is really zero, then E(\\(R^{2}\\)) = P/(N-1). Adjusted \\(R^{2}\\) To alleviate bias use Mean squares instead of SS. \\(R^{2} = 1-\\frac{Model MS}{Total MS}\\) equivalently, \\(R^{2}_{adj} = R^{2} - \\frac{p(1-R^{2})}{n-p-1}\\) Now Adjusted \\(R^{2}\\) is approximately unbiased and won’t inflate as \\(p\\) increases. Mallows \\(C_{p}\\) \\[ C_{p} = (N-P-1)\\left(\\frac{RMSE}{\\hat{\\sigma}^{2}} -1 \\right) + (P+1) \\] Smaller is better When all variables are chosen, \\(P+1\\) is at it’s maximum but the other part of \\(C_{p}\\) is zero since \\(RMSE\\)==\\(\\hat{\\sigma}^{2}\\) Akaike Information Criterion (AIC) A penalty is applied to the deviance that increases as the number of parameters \\(p\\) increase. Tries to find a parsimonious model that is closer to the “truth”. Uses an information function, e.g., the likelihood function \\((LL)\\). \\[ AIC = -2LL + 2p\\] Smaller is better Can also be written as a function of the residual sum of squares (RSS) (in book) Estimates the information in one model relative to other models So if all models suck, your AIC will just tell you which one sucks less. Bayesian Information Criterion (BIC) Similar to AIC. Tries to find a parsimonious model that is more likely to be the “truth”. The smaller BIC, the better. \\[ BIC = -2LL + ln(N)*(P+1)\\] AIC vs BIC Both are “penalized likelihood” functions Each = -2log likelihood + penalty AIC: penalty = 2, BIC: penalty = ln(N) For any N &gt; 7, ln(N) &gt; 2 Thus, BIC penalizes larger models more heavily. They often agree. When they disagree, AIC chooses a larger model than BIC. "],
["what-to-watch-out-for-1.html", "7.8 What to watch out for", " 7.8 What to watch out for Multicollinearity Missing Data Use previous research as a guide Variables not included can bias the results Significance levels are only a guide Perform model diagnostics after selection to check model fit. Use common sense: A sub-optimal subset may make more sense than optimal one "],
["glm.html", "Chapter 8 Generalized Linear Models", " Chapter 8 Generalized Linear Models One of the primary assumptions with linear regression, is that the error terms have a specific distribution. Namely: \\[ \\epsilon_{i} \\sim \\mathcal{N}(0, \\sigma^{2}) \\qquad i=1, \\ldots, n, \\quad \\mbox{and } \\epsilon_{i} \\perp \\epsilon_{j}, i \\neq j \\] When your outcome variable \\(y\\) is non-continuous/non-normal, the above assumption fails dramatically. Generalized Linear Models (GLM) allows for different data type outcomes by allowing the linear portion of the model (\\(\\mathbf{X}\\beta\\)) to be related to the outcome variable \\(y\\) using a link function, that allows the magnitude of the variance of the errors (\\(\\sigma\\)) to be related to the predicted values themselves. There are three overarching types of non-continuous outcomes that can be modeled with GLM’s. Binary data: Logistic or Probit regression Multinomial/categorical data: Multinomial or Ordinal Logistic regression. Count data: Poisson regression At this time these notes goes into depth for Logistic regression only, due to its commonplace in data analysis tools. "],
["fitting-glms-in-r.html", "8.1 Fitting GLMs in R", " 8.1 Fitting GLMs in R Generalized linear regression models can be fit in R using the glm() function. This function can fit an entire family of distributions and can be thought of as \\(E(Y|X) = C(X)\\) where \\(C\\) is the link function that relates \\(Y\\) to \\(X\\). Linear regression: C = Identity function (no change) Logistic regression: C = logit function Poisson regression: C = log function The general syntax is similar to lm(), with the additional required family= argument. See ?family for a list of options. glm(y ~ x1 + x2 + x3, data=DATA, family=&quot;binomial&quot;) "],
["binary-data.html", "8.2 Binary Data", " 8.2 Binary Data Goals: Assess the impact selected covariates have on the probability of an outcome occurring. Predict the likelihood / chance / probability of an event occurring given a certain covariate pattern. Binary data can be fit using a Logistic Model or a Probit Model. Consider an outcome variable \\(Y\\) with two levels: Y = 1 if event, = 0 if no event. Let \\(p_{i} = P(y_{i}=1)\\). The logistic model relates the probability of an event based on a linear combination of X’s. \\[ log\\left( \\frac{p_{i}}{1-p_{i}} \\right) = \\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} + \\ldots + \\beta_{p}x_{pi} \\] Since the odds are defined as the probability an event occurs divided by the probability it does not occur: \\((p/(1-p))\\), the function \\(log\\left(\\frac{p_{i}}{1-p_{i}}\\right)\\) is also known as the log odds, or more commonly called the logit. This is the link function for the logistic regression model. This in essence takes a binary outcome 0/1 variable, turns it into a continuous probability (which only has a range from 0 to 1) Then the logit(p) has a continuous distribution ranging from \\(-\\infty\\) to \\(\\infty\\), which is the same form as a Multiple Linear Regression (continuous outcome modeled on a set of covariates) Back solving the logistic model for \\(p_{i} = e^{\\beta X} / (1+e^{\\beta X})\\) gives us the probability of an event. \\[ p_{i} = \\frac{e^{\\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} + \\ldots + \\beta_{p}x_{pi}}} {1 + e^{\\beta_{0} + \\beta_{1}x_{1i} + \\beta_{2}x_{2i} + \\ldots + \\beta_{p}x_{pi}}} \\] The probit function uses the inverse CDF for the normal distribution as the link function. 8.2.1 Example: The effect of gender on Depression Is gender associated with depression? Read in the depression data and recode sex to be an indicator of being male. depress &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;) names(depress) &lt;- tolower(names(depress)) # make all variable names lower case. Binary outcome variable: Symptoms of Depression (cases) Binary predictor variable: Gender (sex) as an indicator of being female The outcome \\(y\\) is a 0/1 Bernoulli random variable. The sum of a vector of Bernoulli’s (\\(\\sum_{i=1}^{n}y_{i}\\)) has a Binomial distribution. When we specify that family = &quot;binomial&quot; the glm() function auto-assigns “logit” link function. dep_sex_model &lt;- glm(cases ~ sex, data=depress, family=&quot;binomial&quot;) summary(dep_sex_model) ## ## Call: ## glm(formula = cases ~ sex, family = &quot;binomial&quot;, data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.7023 -0.7023 -0.4345 -0.4345 2.1941 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -2.3125 0.3315 -6.976 3.04e-12 *** ## sex 1.0386 0.3767 2.757 0.00583 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 259.40 on 292 degrees of freedom ## AIC: 263.4 ## ## Number of Fisher Scoring iterations: 5 We exponentiate the coefficients to back transform the \\(\\beta\\) estimates into Odds Ratios exp(coef(dep_sex_model)) ## (Intercept) sex ## 0.0990099 2.8251748 Females have 2.8 times the odds of showing signs of depression compared to males. Confidence Intervals The OR is not a linear function of the \\(x&#39;s\\), but \\(\\beta\\) is. This means that a CI for the OR is created by calculating a CI for \\(\\beta\\), and then exponentiating the endpoints. A 95% CI for the OR can be calculated as: \\[e^{\\hat{\\beta} \\pm 1.96 SE_{\\beta}} \\] exp(confint(dep_sex_model)) ## 2.5 % 97.5 % ## (Intercept) 0.04843014 0.1801265 ## sex 1.39911056 6.2142384 8.2.2 Multiple Logistic Regression Just like multiple linear regression, additional predictors are simply included in the model using a + symbol. mvmodel &lt;- glm(cases ~ age + income + sex, data=depress, family=&quot;binomial&quot;) summary(mvmodel) ## ## Call: ## glm(formula = cases ~ age + income + sex, family = &quot;binomial&quot;, ## data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.0249 -0.6524 -0.5050 -0.3179 2.5305 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -0.67646 0.57881 -1.169 0.24253 ## age -0.02096 0.00904 -2.318 0.02043 * ## income -0.03656 0.01409 -2.595 0.00946 ** ## sex 0.92945 0.38582 2.409 0.01600 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 247.54 on 290 degrees of freedom ## AIC: 255.54 ## ## Number of Fisher Scoring iterations: 5 The sign of the \\(\\beta\\) coefficients can be interpreted in the same manner as with linear regression. The odds of being depressed are less if the respondent has a higher income and is older, and higher if the respondent is female. 8.2.3 Interpretation The OR provides a directly understandable statistic for the relationship between \\(y\\) and a specific \\(x\\) given all other \\(x\\)’s in the model are fixed. For a continuous variable X with slope coefficient \\(\\beta\\), the quantity \\(e^{b}\\) is interpreted as the ratio of the odds for a person with value (X+1) relative to the odds for a person with value X. \\(exp(kb)\\) is the incremental odds ratio corresponding to an increase of \\(k\\) units in the variable X, assuming that the values of all other X variables remain unchanged. Where does \\(OR = e^{\\beta}\\) come from? The full model is: \\[log(odds) = -0.676 - 0.02096*age - .03656*income + 0.92945*gender\\] We want to calculate the Odds Ratio of depression for women compared to men. \\[ OR = \\frac{Odds (Y=1|F)}{Odds (Y=1|M)} \\] Write out the equations for men and women separately. \\[ = \\frac{e^{-0.676 - 0.02096*age - .03656*income + 0.92945(1)}} {e^{-0.676 - 0.02096*age - .03656*income + 0.92945(0)}}\\] Applying rules of exponents to simplify. \\[ = \\frac{e^{-0.676}e^{- 0.02096*age}e^{- .03656*income}e^{0.92945(1)}} {e^{-0.676}e^{- 0.02096*age}e^{- .03656*income}e^{0.92945(0)}}\\] \\[ = \\frac{e^{0.92945(1)}} {e^{0.92945(0)}}\\] \\[ = e^{0.92945} \\] exp(.92945) ## [1] 2.533116 exp(coef(mvmodel)[4]) ## sex ## 2.533112 The odds of a female being depressed are 2.53 times greater than the odds for Males after adjusting for the linear effects of age and income (p=.016). 8.2.3.1 Effect of a k unit change Sometimes a 1 unit change in a continuous variable is not meaningful. exp(coef(mvmodel)) ## (Intercept) age income sex ## 0.5084157 0.9792605 0.9640969 2.5331122 exp(confint(mvmodel)) ## 2.5 % 97.5 % ## (Intercept) 0.1585110 1.5491849 ## age 0.9615593 0.9964037 ## income 0.9357319 0.9891872 ## sex 1.2293435 5.6586150 The Adjusted odds ratio (AOR) for increase of 1 year of age is 0.98 (95%CI .96, 1.0) How about a 10 year increase in age? \\(e^{10*\\beta_{age}} = e^{-.21} = .81\\) exp(10*coef(mvmodel)[2]) ## age ## 0.8109285 with a confidence interval of round(exp(10*confint(mvmodel)[2,]),3) ## 2.5 % 97.5 % ## 0.676 0.965 Controlling for gender and income, an individual has 0.81 (95% CI 0.68, 0.97) times the odds of being depressed compared to someone who is 10 years younger than them. 8.2.3.1.1 Example: The relationship between income, employment status and depression. This example follows PMA5 Ch 12.7 Here I create the binary indicators of lowincome (annual income &lt;$10k/year) and underemployed (part time or unemployed). depress$lowincome &lt;- ifelse(depress$income &lt; 10, 1, 0) table(depress$lowincome, depress$income, useNA=&quot;always&quot;) ## ## 2 4 5 6 7 8 9 11 12 13 15 16 18 19 20 23 24 25 26 27 28 31 ## 0 0 0 0 0 0 0 0 17 2 18 24 1 1 25 3 25 2 1 1 1 19 1 ## 1 7 8 10 12 18 14 22 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## &lt;NA&gt; 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## ## 32 35 36 37 42 45 55 65 &lt;NA&gt; ## 0 1 24 1 1 1 15 9 10 0 ## 1 0 0 0 0 0 0 0 0 0 ## &lt;NA&gt; 0 0 0 0 0 0 0 0 0 depress$underemployed &lt;- ifelse(depress$employ %in% c(&quot;PT&quot;, &quot;Unemp&quot;), 1, 0 ) table(depress$underemployed, depress$employ, useNA=&quot;always&quot;) ## ## FT Houseperson In School Other PT Retired Unemp &lt;NA&gt; ## 0 167 27 2 4 0 38 0 0 ## 1 0 0 0 0 42 0 14 0 ## &lt;NA&gt; 0 0 0 0 0 0 0 0 The Main Effects model assumes that the effect of income on depression is independent of employment status, and the effect of employment status on depression is independent of income. me_model &lt;- glm(cases ~ lowincome + underemployed, data=depress, family=&quot;binomial&quot;) summary(me_model) ## ## Call: ## glm(formula = cases ~ lowincome + underemployed, family = &quot;binomial&quot;, ## data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -0.9085 -0.5843 -0.5279 -0.5279 2.0197 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.9003 0.2221 -8.556 &lt; 2e-16 *** ## lowincome 0.2192 0.3353 0.654 0.51322 ## underemployed 1.0094 0.3470 2.909 0.00363 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 259.93 on 291 degrees of freedom ## AIC: 265.93 ## ## Number of Fisher Scoring iterations: 4 To formally test whether an interaction term is necessary, we add the interaction term into the model and assess whether the coefficient for the interaction term is significantly different from zero. me_intx_model &lt;- glm(cases ~ lowincome + underemployed + lowincome*underemployed, data=depress, family=&quot;binomial&quot;) summary(me_intx_model) ## ## Call: ## glm(formula = cases ~ lowincome + underemployed + lowincome * ## underemployed, family = &quot;binomial&quot;, data = depress) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.3537 -0.5790 -0.5790 -0.4717 2.1219 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -1.7011 0.2175 -7.822 5.21e-15 *** ## lowincome -0.4390 0.4324 -1.015 0.31005 ## underemployed 0.2840 0.4501 0.631 0.52802 ## lowincome:underemployed 2.2615 0.7874 2.872 0.00408 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 268.12 on 293 degrees of freedom ## Residual deviance: 251.17 on 290 degrees of freedom ## AIC: 259.17 ## ## Number of Fisher Scoring iterations: 4 8.2.4 Goodness of Fit Tests to see if there is sufficient reason to believe that the data does not fit a logistic model \\(H_{0}\\) The data do come from a logistic model. \\(H_{a}\\) The data do not come from a logistic model. This means that a small p-value indicates that the model does not fit the data. We’ll look specifically at the Hosmer-Lemeshow (HL) Goodness of fit (GoF) test 8.2.4.1 HL GoF Compute the probability (\\(p_{i}\\)) of event (risk) for each observation. Sort data by this \\(p\\). Divide into \\(G\\) equal sized groups in ascending order (G=10 is common, i.e. split into deciles) Then for each group we calculate \\(O_{1g}\\): the observed number of events \\(E_{1g}\\): the expected number of events as the \\(\\sum_{i} p_{ig}\\) \\(O_{0g}\\): the observed number of non-events \\(E_{0g}\\): the expected number of events as the \\(1-\\sum_{i} p_{ig}\\) Then the HL test statistic (\\(H\\)) has a \\(\\chi^{2}\\) distribution and is is calculated as: \\[ H = \\sum_{g=1}^{G}\\left({\\frac {(O_{1g}-E_{1g})^{2}}{E_{1g}}}+{\\frac {(O_{0g}-E_{0g})^{2}}{E_{0g}}}\\right) \\sim \\chi^{2}_{G-2} \\] 8.2.4.2 HL GoF in R MKmisc::HLgof.test(fit = fitted(me_intx_model), obs = me_intx_model$y) ## $C ## ## Hosmer-Lemeshow C statistic ## ## data: fitted(me_intx_model) and me_intx_model$y ## X-squared = 5.614e-17, df = 1, p-value = 1 ## ## ## $H ## ## Hosmer-Lemeshow H statistic ## ## data: fitted(me_intx_model) and me_intx_model$y ## X-squared = 5.614e-17, df = 8, p-value = 1 A very low test statistic and a very high p-value indicate that this model fits the data well. "],
["classification-of-binary-outcomes.html", "8.3 Classification of Binary outcomes", " 8.3 Classification of Binary outcomes Sometimes Odds Ratios can be difficult to interpret or understand. Sometimes you just want to report the probability of the event occurring. Or sometimes you want to predict whether or not a new individual is going to have the event. For all of these, we need to calculate \\(p_{i} = P(y_{i}=1)\\), the probability of the event. For the main effects model of depression on age, income and gender the predicted probability of depression is: \\[ P(depressed) = \\frac{e^{-0.676 - 0.02096*age - .03656*income + 0.92945*gender}} {1 + e^{-0.676 - 0.02096*age - .03656*income + 0.92945*gender}} \\] Let’s compare the probability of being depressed for males and females separately, while holding age and income constant at their average value. depress %&gt;% summarize(age=mean(age), income=mean(income)) ## age income ## 1 44.41497 20.57483 Plug the coefficient estimates and the values of the variables into the equation and calculate. \\[ P(depressed|Female) = \\frac{e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(1)}} {1 + e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(1)}} \\] XB.f &lt;- -0.676 - 0.02096*(44.4) - .03656*(20.6) + 0.92945 exp(XB.f) / (1+exp(XB.f)) ## [1] 0.1930504 \\[ P(depressed|Male) = \\frac{e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(0)}} {1 + e^{-0.676 - 0.02096(44.4) - .03656(20.6) + 0.92945(0)}} \\] XB.m &lt;- -0.676 - 0.02096*(44.4) - .03656*(20.6) exp(XB.m) / (1+exp(XB.m)) ## [1] 0.08629312 The probability for a 44.4 year old female who makes $20.6k annual income has a 0.19 probability of being depressed. The probability of depression for a male of equal age and income is 0.86. 8.3.1 Calculating predictions So what if you want to get the model predicted probability of the event for all individuals in the data set? There’s no way I’m doing that calculation for every person in the data set. Using the main effects model from above, stored in the object mvmodel, we can call the predict() command to generate a vector of predictions for each row used in the model. Any row with missing data on any variable used in the model will NOT get a predicted value. The predict() function can calculate predictions for any GLM. The model object mvmodel stores the information that it was a logistic regression. model.pred.prob &lt;- predict(mvmodel, type=&#39;response&#39;) head(model.pred.prob) ## 1 2 3 4 5 6 ## 0.21108906 0.08014012 0.15266203 0.24527840 0.15208679 0.17056409 8.3.1.1 Distribution of Predictions How well does our model do to predict depression? plot.mpp &lt;- data.frame(prediction = model.pred.prob, truth = factor(mvmodel$y, labels=c(&quot;Not Depressed&quot;, &quot;Depressed&quot;))) ggplot(plot.mpp, aes(x=truth, y=prediction, fill=truth)) + geom_jitter(width=.2) + geom_violin(alpha=.4) + theme_bw() What things can you infer from this plot? Where should we put the cutoff value? At what probability should we classify a record as “depressed”? 8.3.1.2 Optimal Cutoff Value Often we adjust the cutoff value to improve accuracy. This is where we have to put our gut feeling of what probability constitutes “high risk”. For some models, this could be as low as 30%. It’s whatever the probability is that optimally separates the classes. Let’s look at two ways to visualize model performance as a function of cutoff. 8.3.2 ROC Curves We can create a Receiver operating characteristic (ROC) curve to help find that sweet spot. ROC curves show the balance between sensitivity and specificity. We’ll use the [ROCR] package. It only takes 3 commands: calculate prediction() using the model calculate the model performance() on both true positive rate and true negative rate for a whole range of cutoff values. plot the curve. The colorize option colors the curve according to the probability cutoff point. library(ROCR) pr &lt;- prediction(model.pred.prob, mvmodel$y) perf &lt;- performance(pr, measure=&quot;tpr&quot;, x.measure=&quot;fpr&quot;) plot(perf, colorize=TRUE, lwd=3, print.cutoffs.at=c(seq(0,1,by=0.1))) abline(a=0, b=1, lty=2) We can also use the performance() function and say we want to evaluate the \\(f1\\) measure perf.f1 &lt;- performance(pr,measure=&quot;f&quot;) plot(perf.f1) ROC curves: Can also be used for model comparison: http://yaojenkuo.io/diamondsROC.html The Area under the Curve (auc) also gives you a measure of overall model accuracy. auc &lt;- performance(pr, measure=&#39;auc&#39;) auc@y.values ## [[1]] ## [1] 0.695041 8.3.3 Model Performance Say we decide that a value of 0.15 is our optimal cutoff value. We can use this probability to classify each row into groups. The assigned class values must match the data type and levels of the true value. It also has to be in the same order, so the 0 group needs to come first. Then we calculate a [Confusion Matrix] using the similarly named function from the caret package. At it’s core, this is a 2x2 table containing counts of each combination of predicted value and true value. library(caret) plot.mpp$pred.class &lt;- ifelse(plot.mpp$prediction &lt;0.15, 0,1) plot.mpp$pred.class &lt;- factor(plot.mpp$pred.class, labels=c(&quot;Not Depressed&quot;, &quot;Depressed&quot;)) confusionMatrix(plot.mpp$pred.class, plot.mpp$truth, positive=&quot;Depressed&quot;) ## Confusion Matrix and Statistics ## ## Reference ## Prediction Not Depressed Depressed ## Not Depressed 123 10 ## Depressed 121 40 ## ## Accuracy : 0.5544 ## 95% CI : (0.4956, 0.6121) ## No Information Rate : 0.8299 ## P-Value [Acc &gt; NIR] : 1 ## ## Kappa : 0.1615 ## Mcnemar&#39;s Test P-Value : &lt;2e-16 ## ## Sensitivity : 0.8000 ## Specificity : 0.5041 ## Pos Pred Value : 0.2484 ## Neg Pred Value : 0.9248 ## Prevalence : 0.1701 ## Detection Rate : 0.1361 ## Detection Prevalence : 0.5476 ## Balanced Accuracy : 0.6520 ## ## &#39;Positive&#39; Class : Depressed ## 123 people were correctly predicted to not be depressed (True Negative, \\(n_{11}\\)) 121 people were incorrectly predicted to be depressed (False Positive, \\(n_{21}\\)) 10 people were incorrectly predicted to not be depressed (False Negative, \\(n_{12}\\)) 40 people were correctly predicted to be depressed (True Positive, \\(n_{22}\\)) Other terminology: Sensitivity/Recall/True positive rate: P(predicted positive | total positive) = 40/(10+40) = .8 Specificity/true negative rate: P(predicted negative | total negative) = 123/(123+121) = .504 Precision/positive predicted value: P(true positive | predicted positive) = 40/(121+40) = .2484 Accuracy: (TP + TN)/ Total: (40 + 123)/(40+123+121+10) = .5544 Balanced Accuracy: \\([(n_{11}/n_{.1}) + (n_{22}/n_{.2})]/2\\) - This is to adjust for class size imbalances (like in this example) F1 score: the harmonic mean of precision and recall. This ranges from 0 (bad) to 1 (good): \\(2*\\frac{precision*recall}{precision + recall}\\) = 2*(.2484*.8)/(.2484+.8) = .38 "],
["categorical-data.html", "8.4 Categorical Data", " 8.4 Categorical Data Multinomial Regression Ordinal Logistic Regression "],
["count-data.html", "8.5 Count Data", " 8.5 Count Data Lets consider modeling the distribution of the number of of occurrences of a rare event in a specified period of time - e.g. Number of thunderstorms in a year If we assume: Rate (\\(\\mu\\)) is fixed over time Successive occurrences independent of each other Then we can use the Poisson distribution. \\[ P(Y=y) = e^{-\\mu}\\frac{\\mu^{y}}{y!} \\] The Poisson distribution has a distinct feature where the mean of the distribution \\(\\mu\\), is also the variance. Plot of Histogram of a Poisson Distribution with a Mean of 5 and a Normal Curve 8.5.0.1 Poisson Regression Just another GLM - we use a \\(ln\\) as the link function. This lets us model the log rates using a linear combination of covariates. \\[ ln(\\mu) = \\mathbf{X}\\beta \\] Then the expected rate of events per unit of time is: \\[ \\mu = e^{\\mathbf{X}\\beta} \\] This model assumes that the time of “exposure” for each record is identical. Number of cigarettes per month Number of epileptic seizures per week Number of people with lung cancer in four cities If this is not the case (often), then this model needs to include an offset. e.g. observing each patient for epileptic seizures for a different number of days accounting for different sizes or structures of populations of interest (e.g. different cities with lung cancer) What actually gets fit in glm is the model of expected counts, rather than rates, with an offset for the time period \\(T\\). If all time periods are the same, then T is constant, and a linear combination of the intercept, thus dropped from the model. \\[ ln(\\lambda) = \\mathbf{X}\\beta + ln(T) \\] While this offset will be added to the regression model as if it were another variable, it’s not quite the same because the regression coefficient for the \\(ln(T)\\) term is fixed at 1. The generic formula for fitting a poisson model using glm is: glm(y ~ x1 + x2 + offset(log(T)), family=&#39;poisson&#39;) or alternatively as an argument glm(y ~ x1 + x2, offset = log(T), family=&#39;poisson&#39;) The interpretation of the \\(\\beta\\) regression coefficients are differences in the log rate (or the log rate-ratio). So, just like with a logistic regression often we back-transform the coefficients by exponentiating before interpreting. So \\(e^{\\beta}\\) is now the rate-ratio. The intercept term is not a ratio, but a baseline rate when all covariates are 0 For other covariates, the coefficient is the relative change per unit change in the covariate. one year older males vs females Also, similar to logistic regression, since the outcome was transformed, the standard errors are not useful or interpretable as is. To calculate confidence intervals for the rate ratios, calculate the CI for \\(\\beta\\) exponentiate each end point. 8.5.0.2 Example: Modeling counts from the Add Health data Wave IVset. better example forthcoming Let’s model the number of siblings someone has, based off their age at Wave 1 (2008). Visualize hist(addhealth$nsib, xlab=&quot;Number of siblings&quot;, ylab=&quot;Count&quot;, main=&quot;&quot;,axes=FALSE, ylim=c(0,3000)) axis(1);axis(2, las=2);box() nsib.model &lt;- glm(nsib ~ agew1 + female, data=addhealth, family=&quot;poisson&quot;) pander(summary(nsib.model)) Estimate Std. Error z value Pr(&gt;|z|) (Intercept) 0.2647 0.1014 2.611 0.009019 agew1 0.0443 0.005989 7.397 1.39e-13 female 0.0969 0.01909 5.076 3.851e-07 (Dispersion parameter for poisson family taken to be 1 ) Null deviance: 6411 on 3917 degrees of freedom Residual deviance: 6335 on 3915 degrees of freedom betas &lt;- cbind(coef(nsib.model), confint(nsib.model)) kable(exp(betas), digits=3) 2.5 % 97.5 % (Intercept) 1.303 1.068 1.589 agew1 1.045 1.033 1.058 female 1.102 1.061 1.144 "],
["mv-intro.html", "Chapter 9 Introduction", " Chapter 9 Introduction There is an important distinction between multivariable and multivariate models. multivariable : Multiple predictor variables (\\(\\mathbf{x}\\)). multivariate: Multiple response variables (\\(\\mathbf{Y}\\)). Often analysts will misuse multivaraite when they really mean multivariable. Multivariate techniques are Primarily used as an exploratory technique Restructure interrelated variables Simplify description Reduce dimensionality Avoid multicollinearity problems in regression We will discuss two different, but related techniques: Principal Component Analysis and Factor Analysis. "],
["pca.html", "Chapter 10 Principal Component Analysis", " Chapter 10 Principal Component Analysis More nomenclature tidbits: It’s “Principal” Components (adjective), not “Principle” Components (noun) From Grammerist: As a noun, principal refers to (1) one who holds a presiding position or rank, and (2) capital or property before interest, and it’s also an adjective meaning (3) first or most important in rank Principle is only a noun. In its primary sense, it refers to a basic truth, law, assumption, or rule. This third definition (3) is the context in which we will be using this term. Not variable selection Principal Components Analysis (PCA) differs from variable selection in two ways: No dependent variable exists Variables are not eliminated but rather summary variables, i.e., principal components, are computed from all of the original variables. We are trying to understand a phenomenon by collecting a series of component measurements, but the underlying mechanics is complex and not easily understood by simply looking at each component individually. The data could be redundant and high levels of multicolinearity may be present. "],
["basic-idea.html", "10.1 Basic Idea", " 10.1 Basic Idea Consider a hypothetical data set that consists of 100 random pairs of observations \\(X_{1}\\) and \\(X_{2}\\) that are correlated. Let \\(X_{1} \\sim \\mathcal{N}(100, 100)\\), \\(X_{2} \\sim \\mathcal{N}(50, 50)\\), with \\(\\rho_{12} = \\frac{1}{\\sqrt{2}}\\). In matrix notation this is written as: \\(\\mathbf{X} \\sim \\mathcal{N}\\left(\\mathbf{\\mu}, \\mathbf{\\Sigma}\\right)\\) where \\[\\mathbf{\\mu} = \\left(\\begin{array} {r} \\mu_{1} \\\\ \\mu_{2} \\end{array}\\right), \\mathbf{\\Sigma} = \\left(\\begin{array} {cc} \\sigma_{1}^{2} &amp; \\rho_{12}\\sigma_{x}\\sigma_{y} \\\\ \\rho_{12}\\sigma_{x}\\sigma_{y} &amp; \\sigma_{2}^{2} \\end{array}\\right) \\]. set.seed(456) m &lt;- c(100, 50) s &lt;- matrix(c(100, sqrt(.5*100*50), sqrt(.5*100*50), 50), nrow=2) data &lt;- data.frame(MASS::mvrnorm(n=100, mu=m, Sigma=s)) colnames(data) &lt;- c(&quot;X1&quot;, &quot;X2&quot;) plot(X2 ~ X1, data=data, pch=16) Goal: Create two new variables \\(C_{1}\\) and \\(C_{2}\\) as linear combinations of \\(\\mathbf{x_{1}}\\) and \\(\\mathbf{x_{2}}\\) \\[ \\mathbf{C_{1}} = a_{11}\\mathbf{x_{1}} + a_{12}\\mathbf{x_{2}} \\] \\[ \\mathbf{C_{2}} = a_{21}\\mathbf{x_{1}} + a_{22}\\mathbf{x_{2}} \\] or more simply \\(\\mathbf{C = aX}\\), where The \\(\\mathbf{x}\\)’s have been centered by subtracting their mean (\\(\\mathbf{x_{1}} = x_{1}-\\bar{x_{1}}\\)) \\(Var(C_{1})\\) is as large as possible Graphically we’re creating two new axes, where now \\(C_{1}\\) and \\(C_{2}\\) are uncorrelated. PCA is mathematically defined as an orthogonal linear transformation that transforms the data to a new coordinate system such that the greatest variance by some projection of the data comes to lie on the first coordinate (called the first principal component), the second greatest variance on the second coordinate, and so on. Wikipedia "],
["more-generally.html", "10.2 More Generally", " 10.2 More Generally We want From \\(P\\) original variables \\(X_{1}, \\ldots , X_{P}\\) get \\(P\\) principal components \\(C_{1}, \\ldots , C_{P}\\) Where each \\(C_{j}\\) is a linear combination of the \\(X_{i}\\)’s: \\(C_{j} = a_{j1}X_{1} + a_{j2}X_{2} + \\ldots + a_{jP}X_{P}\\) The coefficients are chosen such that \\(Var(C_{1}) \\geq Var(C_{2}) \\geq \\ldots \\geq Var(C_{P})\\) Variance is a measure of information. Consider modeling prostate cancer. Gender has 0 variance. No information. Size of tumor: the variance is &gt; 0, it provides useful information. Any two PC’s are uncorrelated: \\(Cov(C_{i}, C_{j})=0, \\quad \\forall i \\neq j\\) We have \\[ \\left[ \\begin{array}{r} C_{1} \\\\ C_{2} \\\\ \\vdots \\\\ C_{P} \\end{array} \\right] = \\left[ \\begin{array}{cccc} a_{11} &amp; a_{12} &amp; \\ldots &amp; a_{1P} \\\\ a_{21} &amp; a_{22} &amp; \\ldots &amp; a_{2P} \\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ a_{P1} &amp; a_{P2} &amp; \\ldots &amp; a_{PP} \\end{array} \\right] \\left[ \\begin{array}{r} X_{1} \\\\ X_{2} \\\\ \\vdots \\\\ X_{P} \\end{array} \\right] \\] Hotelling (1933) showed that the \\(a_{ij}\\)’s are solutions to \\((\\mathbf{\\Sigma} -\\lambda\\mathbf{I})\\mathbf{a}=\\mathbf{0}\\). \\(\\mathbf{\\Sigma}\\) is the variance-covariance matrix of the \\(\\mathbf{X}\\) variables. This means \\(\\lambda\\) is an eigenvalue and \\(\\mathbf{a}\\) an eigenvector of the covariance matrix \\(\\mathbf{\\Sigma}\\). Problem: There are infinite number of possible \\(\\mathbf{a}\\)’s Solution: Choose \\(a_{ij}\\)’s such that the sum of the squares of the coefficients for any one eigenvector is = 1. \\(P\\) unique eigenvalues and \\(P\\) corresponding eigenvectors. Which gives us Variances of the \\(C_{j}\\)’s add up to the sum of the variances of the original variables (total variance). Can be thought of as variance decomposition into orthogonal (independet) vectors (variables). With \\(Var(C_{1}) \\geq Var(C_{2}) \\geq \\ldots \\geq Var(C_{P})\\). "],
["generating-pcs-using-r.html", "10.3 Generating PC’s using R", " 10.3 Generating PC’s using R Calculating the principal components in R can be done using a call to the function prcomp(). STHDA has a good overview of the difference between prcomp() and princomp(). pr &lt;- princomp(data) summary(pr) ## Importance of components: ## Comp.1 Comp.2 ## Standard deviation 11.4019265 4.2236767 ## Proportion of Variance 0.8793355 0.1206645 ## Cumulative Proportion 0.8793355 1.0000000 The summary output above shows the first PC (Comp.1) explains the highest proportion of variance. The values for the matrix \\(\\mathbf{A}\\) is contained in pr$loadings. pr$loadings ## ## Loadings: ## Comp.1 Comp.2 ## X1 -0.854 0.519 ## X2 -0.519 -0.854 ## ## Comp.1 Comp.2 ## SS loadings 1.0 1.0 ## Proportion Var 0.5 0.5 ## Cumulative Var 0.5 1.0 To visualize these new axes, we plot the centered data. a &lt;- pr$loadings x1 &lt;- with(data, X1 - mean(X1)) x2 &lt;- with(data, X2 - mean(X2)) plot(c(-40, 40), c(-20, 20), type=&quot;n&quot;,xlab=&quot;x1&quot;, ylab=&quot;x2&quot;) points(x=x1, y=x2, pch=16) abline(0, a[2,1]/a[1,1]); text(30, 10, expression(C[1])) abline(0, a[2,2]/a[1,2]); text(-10, 20, expression(C[2])) Plot the original data on the new axes we see that PC1 and PC2 are uncorrelated. The red vectors show you where the original coordinates were at. biplot(pr) "],
["using-the-correlation-matrix.html", "10.4 Using the correlation matrix", " 10.4 Using the correlation matrix Standardizing: Take \\(X\\) and divide each element by \\(\\sigma_{x}\\). \\(Z = X/\\sigma_{X}\\) Side note: Standardizing and centering == normalizing \\(Z = (X-\\bar{X})/\\sigma_{X}\\) Equivalent to analyzing the correlation matrix (\\(\\mathbf{R}\\)) instead of covariance matrix (\\(\\mathbf{\\Sigma}\\)). Using correlation matrix vs covariance matrix will generate different PC’s This makes sense given the difference in matricies: cov(data) #Covariance Matrix ## X1 X2 ## X1 100.74146 50.29187 ## X2 50.29187 48.59528 cor(data) #Correlation Matrix ## X1 X2 ## X1 1.0000000 0.7187811 ## X2 0.7187811 1.0000000 Standardizing your data prior to analysis aids the interpretation of the PC’s in a few ways The total variance is the number of variables \\(P\\) The proportion explained by each PC is the corresponding eigenvalue / \\(P\\) The correlation between \\(C_{i}\\) and standardized variable \\(x_{j}\\) can be written as \\(r_{ij} = a_{ij}SD(C_{i})\\) This last point means that for any given \\(C_{i}\\) we can quantify the relative degree of dependence of the PC on each of the standardized variables. This is a.k.a. the factor loading (we will return to this key term later). To calculate the principal components using the correlation matrix, you just need to specify that you want cor=TRUE. pr_corr &lt;- princomp(data, cor=TRUE) summary(pr_corr) ## Importance of components: ## Comp.1 Comp.2 ## Standard deviation 1.3110229 0.5303008 ## Proportion of Variance 0.8593906 0.1406094 ## Cumulative Proportion 0.8593906 1.0000000 If we use the covariance matrix and change the scale of a variable (i.e. in to cm) that will change the results of the PC’s Many researchers prefer to use the correlation matrix It compensates for the units of measurements for the different variables. Interpretations are made in terms of the standardized variables. "],
["data-reduction.html", "10.5 Data Reduction", " 10.5 Data Reduction Keep first \\(m\\) principal components as representatives of original P variables Keep enough to explain a large percentage of original total variance. Ideally you want a small number of PC’s that explain a large percentage of the total variance. Choosing \\(m\\) Rely on existing theory Explain a given % of variance (cumulative percentage plot) All eigenvalues &gt; 1 (Scree plot) Elbow rule (Scree Plot) These last two will be best explained using an example. "],
["example-analysis-of-depression.html", "10.6 Example Analysis of depression", " 10.6 Example Analysis of depression This example follows Analysis of depression data set section in PMA5 Section 14.5. This survey asks 20 questions on emotional states that relate to depression. Here I use PCA to reduce these 20 correlated variables down to a few uncorrelated variables that explain the most variance. 1. Read in the data and run princomp on the C1:C20 variables. depress &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/depress_081217.txt&quot;, header=TRUE) pc_dep &lt;- princomp(depress[,9:28], cor=TRUE) summary(pc_dep) ## Importance of components: ## Comp.1 Comp.2 Comp.3 Comp.4 ## Standard deviation 2.6562036 1.21883931 1.10973409 1.03232021 ## Proportion of Variance 0.3527709 0.07427846 0.06157549 0.05328425 ## Cumulative Proportion 0.3527709 0.42704935 0.48862483 0.54190909 ## Comp.5 Comp.6 Comp.7 Comp.8 ## Standard deviation 1.00629648 0.98359581 0.97304489 0.87706188 ## Proportion of Variance 0.05063163 0.04837304 0.04734082 0.03846188 ## Cumulative Proportion 0.59254072 0.64091375 0.68825457 0.72671645 ## Comp.9 Comp.10 Comp.11 Comp.12 ## Standard deviation 0.83344885 0.81248191 0.77950975 0.74117295 ## Proportion of Variance 0.03473185 0.03300634 0.03038177 0.02746687 ## Cumulative Proportion 0.76144830 0.79445464 0.82483641 0.85230328 ## Comp.13 Comp.14 Comp.15 Comp.16 ## Standard deviation 0.73255278 0.71324438 0.67149280 0.61252016 ## Proportion of Variance 0.02683168 0.02543588 0.02254513 0.01875905 ## Cumulative Proportion 0.87913496 0.90457083 0.92711596 0.94587501 ## Comp.17 Comp.18 Comp.19 Comp.20 ## Standard deviation 0.56673129 0.54273638 0.51804873 0.445396635 ## Proportion of Variance 0.01605922 0.01472814 0.01341872 0.009918908 ## Cumulative Proportion 0.96193423 0.97666237 0.99008109 1.000000000 2. Pick a subset of PC’s to work with In the cumulative percentage plot below, I drew a horizontal line at 80%. So the first 9 PC’s explain around 75% of the total variance, and the first 10 can explain around 80%. library(ggplot2) var_pc &lt;- (pc_dep$sdev)^2 qplot(x=1:20, y=cumsum(var_pc)/sum(var_pc)*100, geom=&quot;point&quot;) + xlab(&quot;PC number&quot;) + ylab(&quot;Cumulative %&quot;) + ylim(c(0,100)) + geom_hline(aes(yintercept=80)) 3. Create a Scree plot by plotting the eigenvalue against the PC number. qplot(x=1:20, y=var_pc, geom=c(&quot;point&quot;, &quot;line&quot;)) + xlab(&quot;PC number&quot;) + ylab(&quot;Eigenvalue&quot;) + ylim(c(0,8)) Option 1: Take all eigenvalues &gt; 1 (\\(m=5\\)) Option 2: Use a cutoff point where the lines joining consecutive points are steep to the left of the cutoff point and flat right of the cutoff point. Point where the two slopes meet is the elbow. (\\(m=2\\)). 4. Examine the loadings pc_dep$loadings[1:3,1:5] ## Comp.1 Comp.2 Comp.3 Comp.4 Comp.5 ## c1 0.2774384 -0.14497938 0.05770239 -0.002723687 -0.08826773 ## c2 0.3131829 0.02713557 0.03162990 0.247811083 -0.02439748 ## c3 0.2677985 -0.15471968 0.03459037 0.247246879 0.21830547 Here \\(X_{1}\\) = “I felt that I could not shake…” \\(X_{2}\\) = “I felt depressed…” So the PC’s are calculated as \\[ C_{1} = 0.277x_{1} + 0.313x_{2} + \\ldots \\\\ C_{2} = -0.1449x_{1} + 0.0271x_{2} + \\ldots \\] etc… The full question text for the depression data used here can be found on Table 15.7 in the PMA5 textbook. 5. Interpret the PC’s Visualize the loadings using heatmap.2() in the gplots package. I reversed the colors so that red was high positive correlation and yellow/white is low. half the options I use below come from this SO post. I had no idea what they did, so I took what the solution showed, and played with it (added/changed some to see what they did), and reviewed ?heatmap.2 to see what options were available. library(gplots) heatmap.2(pc_dep$loadings[,1:5], scale=&quot;none&quot;, Rowv=NA, Colv=NA, density.info=&quot;none&quot;, dendrogram=&quot;none&quot;, trace=&quot;none&quot;, col=rev(heat.colors(256))) Loadings over 0.5 (red) help us interpret what these components could “mean” Must know exact wording of component questions \\(C_{1}\\): a weighted average of most items. High value indicates the respondent had many symptoms of depression. Note sign of loadings are all positive and all roughly the same color. Recall \\(C_{2}\\): lethargy (high energetic). High loading on c14, 16, 17, low on 4, 8, 20 \\(C_{3}\\): friendliness of others. Large negative loading on c19, c9 etc. "],
["use-in-multiple-regression.html", "10.7 Use in Multiple Regression", " 10.7 Use in Multiple Regression Choose a handful of few principal components to use as predictors in a regression model Leads to more stable regression estimates. Alternative to variable selection Ex: several measures of behavior. Use PC\\(_{1}\\) or PC\\(_{1}\\) and PC\\(_{2}\\) as summary measures of all. "],
["things-to-watch-out-for.html", "10.8 Things to watch out for", " 10.8 Things to watch out for Eigenvalues are estimated variances of the PC’s and so are subject to large sample variations. The size of variance of last few principal components can be useful as indicator of multicollinearity among original variables Principal components derived from standardized variables differ from those derived from original variables Important that measurements are accurate, especially for detection of collinearity Arbitrary cutoff points should not be taken too seriously "],
["additional-references.html", "10.9 Additional References", " 10.9 Additional References A collection of other tools and websites that do a good job of explaining PCA. Principal Component Analysis Essentials in R tutorial by [STHDA]](http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/112-pca-principal-component-analysis-essentials/) Stack Overflow This has animations, and walks through the explanation using wine and “how you would explain it to your grandma”. "],
["fa.html", "Chapter 11 Factor Analysis", " Chapter 11 Factor Analysis Example 1 An investigator has asked each respondent in a survey whether he or she strongly agrees, agrees, is undecided, disagrees, or strongly disagrees with 15 statements concerning attitudes toward inflation. As a first step, the investigator will do a factor analysis on the resulting data to determine which statements belong together in sets that are uncorrelated with other sets. The particular statements that form a single set will be examined to obtain a better understanding of attitudes toward inflation. Scores derived from each set or factor will be used in subsequent analysis to predict consumer spending. Example 2 There are Fifty test questions Each is a function of 3 factors: Verbal, quantitative, analytical skills You are interested in measuring the gain in analytical skills over the course of a week after doing some task. "],
["introduction.html", "11.1 Introduction", " 11.1 Introduction This set of notes uses functions from several new packages. See the links in the Additional Resources section for more information library(corrplot) library(psych) library(ggfortify) # plots scores from `factanal()` library(GPArotation) # to do oblimin rotation 11.1.1 Latent Constructs Latent variables are ones that cannot be measured directly; e.g. Depression, Anxiety, Mathematical ability. They drive how we would respond to various tasks and questions that can be measured; vocabulary, arithmetic, statistical reasoning. How can the correlation in responses to questions help us measure these latent constructs? Factor Analysis aims to Generalize of principal components analysis Explain interrelationships among a set of variables Where we select a small number of factors to convey essential information Can perform additional analyses to improve interpretation 11.1.2 EFA vs CFA Exploratory Factor Analysis Explore the possible underlying factor structure of a set of observed variables Does not impose a preconceived structure on the outcome. Confirmatory Factor Analysis Verifies the theoretical factor structure of a set of observed variables Test the relationship between observed variables and theoretical underlying latent constructs Variable groupings are determined ahead of time. "],
["factor-model.html", "11.2 Factor Model", " 11.2 Factor Model Start with P standardized variables. That is \\(\\frac{(x_{i}-\\bar{x})}{s_{i}}\\). So for the rest of these FA notes, understand that each \\(X\\) written has already been standardized. Express each variable as (its own) linear combination of \\(m\\) common factors plus a unique factor \\(e\\). \\(m &lt;&lt; P\\). Ideally \\(m\\) is known in advance \\[ X_{1} = l_{11}F_{1} + l_{12}F_{2} + \\ldots + l_{1m}F_{m} + e_{1} \\\\ X_{2} = l_{21}F_{1} + l_{22}F_{2} + \\ldots + l_{2m}F_{m} + e_{1} \\\\ \\vdots \\\\ X_{P} = l_{P1}F_{1} + l_{P2}F_{2} + \\ldots + l_{Pm}F_{m} + e_{P} \\] \\(X_{i} = \\sum l_{ij} F_{j}+ \\epsilon_{i}\\) \\(F_{j}\\) = common or latent factors \\(e_{i}\\) = unique factors \\(l_{ij}\\) = coefficients of common factors = factor loadings Each \\(F_{j}\\) has mean 0 and variance 1 \\(F_{j}\\)’s are uncorrelated $e_{i}’s and \\(F_{j}\\)’s are uncorrelated How does this compare to the equations for Principal Components? 11.2.1 Comparison with PCA Similar in that no dependent variable PCA: Select a number of components that explain as much of the total variance as possible. FA: Factors selected mainly to explain the interrelationships among the original variables. Ideally, the number of factors expected is known in advance. Major emphasis is placed on obtaining easily understandable factors that convey the essential information contained in the original set of variables. https://www.researchgate.net/figure/Conceptual-distinction-between-factor-analysis-and-principal-component-analysis-ote-An_fig1_47386956 Mirror image of PCA Each PC is expressed as a linear combination of X’s Each \\(X\\) is expressed as a linear combination of Factors 11.2.2 Implications Variance of any original \\(X\\) is composed of communality: part due to common factors specificity: part due to a unique factor = 1 when \\(X\\)’s are standardized. \\[ V(X_{i}) = communality + specificity \\\\ \\qquad = h^{2}_{i} + u^{2}_{i} \\] 11.2.3 Two big steps Initial factor extraction: estimate loadings and communalities Factor “rotations” to improve interpretation "],
["fa-example.html", "11.3 Example setup", " 11.3 Example setup Generate 100 data points from the following multivariate normal distribution: \\[\\mathbf{\\mu} = \\left(\\begin{array} {r} 0.163 \\\\ 0.142 \\\\ 0.098 \\\\ -0.039 \\\\ -0.013 \\end{array}\\right), \\mathbf{\\Sigma} = \\left(\\begin{array} {cc} 1 &amp; &amp; &amp; &amp; &amp; \\\\ 0.757 &amp; 1 &amp; &amp; &amp; &amp; \\\\ 0.047 &amp; 0.054 &amp; 1 &amp; &amp; &amp; \\\\ 0.155 &amp; 0.176 &amp; 0.531 &amp; 1 &amp; \\\\ 0.279 &amp; 0.322 &amp; 0.521 &amp; 0.942 &amp; 1 \\end{array}\\right) \\]. set.seed(456) m &lt;- c(0.163, 0.142, 0.098, -0.039, -0.013) s &lt;- matrix(c(1.000, 0.757, 0.047, 0.155, 0.279, 0.757, 1.000, 0.054, 0.176, 0.322, 0.047, 0.054, 1.000, 0.531, 0.521, 0.155, 0.176, 0.531, 1.000, 0.942, 0.279, 0.322, 0.521, 0.942, 1.000), nrow=5) data &lt;- data.frame(MASS::mvrnorm(n=100, mu=m, Sigma=s)) colnames(data) &lt;- paste0(&quot;X&quot;, 1:5) Standardize the \\(X\\)’s. stan.dta &lt;- as.data.frame(scale(data)) The hypothetical data model is that these 5 variables are generated from 2 underlying factors. \\[ \\begin{equation} \\begin{aligned} X_{1} &amp;= (1)*F_{1} + (0)*F_{2} + e_{1} \\\\ X_{2} &amp;= (1)*F_{1} + (0)*F_{2} + e_{2} \\\\ X_{3} &amp;= (0)*F_{1} + (.5)*F_{2} + e_{3} \\\\ X_{4} &amp;= (0)*F_{1} + (1.5)*F_{2} + e_{4} \\\\ X_{5} &amp;= (0)*F_{1} + (2)*F_{2} + e_{5} \\\\ \\end{aligned} \\end{equation} \\] Implications \\(F_{1}, F_{2}\\) and all \\(e_{i}\\)’s are independent normal variables The first two \\(X\\)’s are inter-correlated, and the last 3 \\(X\\)’s are inter-correlated The first 2 \\(X\\)’s are NOT correlated with the last 3 \\(X\\)’s #library(corrplot) corrplot(cor(stan.dta), tl.col=&quot;black&quot;) "],
["fa-extract.html", "11.4 Factor Extraction", " 11.4 Factor Extraction Methods PC Factor Model Iterated PC Factor Model Maximum Likelihood Choose the first \\(m\\) principal components and modify them to fit the factor model defined in the previous section. They explain the greatest proportion of the variance and are therefore the most important extract_pca &lt;- princomp(stan.dta) var_pc &lt;- (extract_pca$sdev)^2 qplot(x=1:length(var_pc), y=var_pc, geom=c(&quot;point&quot;, &quot;line&quot;)) + xlab(&quot;PC number&quot;) + ylab(&quot;Eigenvalue&quot;) 11.4.1 PC Factor Model Recall that \\(\\mathbf{C} = \\mathbf{A}\\mathbf{X}\\), C’s are a function of X \\[ X_{1} = a_{11}C_{1} + a_{12}C_{2} + \\ldots + a_{1P}C_{p} \\] We want the reverse: X’s are a function of F’s. Use the inverse! –&gt; If \\(c = 5x\\) then \\(x = 5^{-1}C\\) The inverse PC model is \\(\\mathbf{X} = \\mathbf{A}^{-1}\\mathbf{C}\\). Since \\(\\mathbf{A}\\) is orthogonal, \\(\\mathbf{A}^{-1} = \\mathbf{A}^{T} = \\mathbf{A}^{&#39;}\\), so \\[ X_{1} = a_{11}C_{1} + a_{21}C_{2} + \\ldots + a_{P1}C_{p} \\] But there are more PC’s than Factors… \\[ \\begin{equation} \\begin{aligned} X_{i} &amp;= \\sum_{j=1}^{P}a_{ji}C_{j} \\\\ &amp;= \\sum_{j=1}^{m}a_{ji}C_{j} + \\sum_{j=m+1}^{m}a_{ji}C_{j} \\\\ &amp;= \\sum_{j=1}^{m}l_{ji}F_{j} + e_{i} \\\\ \\end{aligned} \\end{equation} \\] Adjustment \\(V(C_{j}) = \\lambda_{j}\\) not 1 We transform: \\(F_{j} = C_{j}\\lambda_{j}^{-1/2}\\) Now \\(V(F_{j}) = 1\\) Loadings: \\(l_{ij} = \\lambda_{j}^{1/2}a_{ji}\\) \\(l_{ij}\\) is the correlation coefficient between variable \\(i\\) and factor \\(j\\) 11.4.2 Iterated PC Factor Model Select common factors to maximize the total communality Get initial communality estimates Use these (instead of original variances) to get the PC’s and factor loadings Get new communality estimates Rinse and repeat Stop when no appreciable changes occur. 11.4.3 Maximum Likelihood Assume that all the variables are normally distributed Use Maximum Likelihood to estimate the parameters 11.4.4 Example PC Factor Model using the principal function in the psych package. #library(psych) pc.extract.norotate &lt;- principal(stan.dta, nfactors=2, rotate=&quot;none&quot;) print(pc.extract.norotate) ## Principal Components Analysis ## Call: principal(r = stan.dta, nfactors = 2, rotate = &quot;none&quot;) ## Standardized loadings (pattern matrix) based upon correlation matrix ## PC1 PC2 h2 u2 com ## X1 0.53 0.78 0.90 0.104 1.8 ## X2 0.59 0.74 0.89 0.106 1.9 ## X3 0.70 -0.39 0.64 0.360 1.6 ## X4 0.87 -0.38 0.90 0.099 1.4 ## X5 0.92 -0.27 0.91 0.087 1.2 ## ## PC1 PC2 ## SS loadings 2.71 1.53 ## Proportion Var 0.54 0.31 ## Cumulative Var 0.54 0.85 ## Proportion Explained 0.64 0.36 ## Cumulative Proportion 0.64 1.00 ## ## Mean item complexity = 1.6 ## Test of the hypothesis that 2 components are sufficient. ## ## The root mean square of the residuals (RMSR) is 0.08 ## with the empirical chi square 12.61 with prob &lt; 0.00038 ## ## Fit based upon off diagonal values = 0.97 \\[ \\begin{equation} \\begin{aligned} X_{1} &amp;= 0.53F_{1} + 0.78F_{2} + e_{1} \\\\ X_{2} &amp;= 0.59F_{1} + 0.74F_{2} + e_{2} \\\\ X_{3} &amp;= 0.70F_{1} - 0.39F_{2} + e_{3} \\\\ X_{4} &amp;= 0.87F_{1} - 0.38F_{2} + e_{4} \\\\ X_{5} &amp;= 0.92F_{1} - 0.27F_{2} + e_{5} \\\\ \\end{aligned} \\end{equation} \\] Using ML extraction. The cutoff argument hides loadings under that value for ease of interpretation. Here I am setting that cutoff at 0 so that all loadings are being displayed. ml.extract.norotate &lt;- factanal(stan.dta, factors=2, rotation=&quot;none&quot;) print(ml.extract.norotate, digits=2, cutoff=0) ## ## Call: ## factanal(x = stan.dta, factors = 2, rotation = &quot;none&quot;) ## ## Uniquenesses: ## X1 X2 X3 X4 X5 ## 0.37 0.00 0.63 0.06 0.04 ## ## Loadings: ## Factor1 Factor2 ## X1 -0.06 0.79 ## X2 -0.07 1.00 ## X3 0.58 0.19 ## X4 0.93 0.28 ## X5 0.90 0.39 ## ## Factor1 Factor2 ## SS loadings 2.02 1.88 ## Proportion Var 0.40 0.38 ## Cumulative Var 0.40 0.78 ## ## Test of the hypothesis that 2 factors are sufficient. ## The chi square statistic is 0.2 on 1 degree of freedom. ## The p-value is 0.652 The uniqueness’s (\\(u^{2}\\)) for X2, X4, X5 are pretty low. The factor equations now are: \\[ \\begin{equation} \\begin{aligned} X_{1} &amp;= -0.06F_{1} + 0.79F_{2} + e_{1} \\\\ X_{2} &amp;= -0.07F_{1} + 1F_{2} + e_{2} \\\\ X_{3} &amp;= 0.58F_{1} + 0.19F_{2} + e_{3} \\\\ \\vdots \\end{aligned} \\end{equation} \\] load &lt;- ml.extract.norotate$loadings[,1:2] plot(load, type=&quot;n&quot;) # set up the plot but don&#39;t put points down text(load, labels=rownames(load)) # put names instead of points Notice that neither extraction method reproduced our true hypothetical factor model. Rotating the factors will achieve our desired results. "],
["rotating-factors.html", "11.5 Rotating Factors", " 11.5 Rotating Factors Find new factors that are easier to interpret For each \\(X\\), we want some high/large (near 1) loadings and some low/small (near zero) Two common rotation methods 11.5.1 Varimax Rotation Restricts the new axes to be orthogonal to each other. (Factors are independent) Maximizes the sum of the variances of the squared factor loadings within each factor \\(\\sum Var(l_{ij}^{2}|F_{j})\\) Interpretations slightly less clear pc.extract.varimax &lt;- principal(stan.dta, nfactors=2, rotate=&quot;varimax&quot;) print(pc.extract.varimax) ## Principal Components Analysis ## Call: principal(r = stan.dta, nfactors = 2, rotate = &quot;varimax&quot;) ## Standardized loadings (pattern matrix) based upon correlation matrix ## RC1 RC2 h2 u2 com ## X1 0.07 0.94 0.90 0.104 1.0 ## X2 0.13 0.94 0.89 0.106 1.0 ## X3 0.80 0.02 0.64 0.360 1.0 ## X4 0.94 0.11 0.90 0.099 1.0 ## X5 0.93 0.23 0.91 0.087 1.1 ## ## RC1 RC2 ## SS loadings 2.41 1.83 ## Proportion Var 0.48 0.37 ## Cumulative Var 0.48 0.85 ## Proportion Explained 0.57 0.43 ## Cumulative Proportion 0.57 1.00 ## ## Mean item complexity = 1 ## Test of the hypothesis that 2 components are sufficient. ## ## The root mean square of the residuals (RMSR) is 0.08 ## with the empirical chi square 12.61 with prob &lt; 0.00038 ## ## Fit based upon off diagonal values = 0.97 ml.extract.varimax &lt;- factanal(stan.dta, factors=2, rotation=&quot;varimax&quot;) print(ml.extract.varimax, digits=2, cutoff=.3) ## ## Call: ## factanal(x = stan.dta, factors = 2, rotation = &quot;varimax&quot;) ## ## Uniquenesses: ## X1 X2 X3 X4 X5 ## 0.37 0.00 0.63 0.06 0.04 ## ## Loadings: ## Factor1 Factor2 ## X1 0.79 ## X2 0.99 ## X3 0.61 ## X4 0.97 ## X5 0.96 ## ## Factor1 Factor2 ## SS loadings 2.26 1.64 ## Proportion Var 0.45 0.33 ## Cumulative Var 0.45 0.78 ## ## Test of the hypothesis that 2 factors are sufficient. ## The chi square statistic is 0.2 on 1 degree of freedom. ## The p-value is 0.652 11.5.2 Oblique rotation Same idea as varimax, but drop the orthogonality requirement Factors are still correlated Better interpretation Methods: quartimax or quartimin minimizes the number of factors needed to explain each variable direct oblimin standard method, but results in diminished interpretability of factors promax is computationally faster than direct oblimin, so good for very large datasets pc.extract.oblimin &lt;- principal(stan.dta, nfactors=2, rotate=&quot;oblimin&quot;) ml.extract.promax&lt;- factanal(stan.dta, factors=2, rotation=&quot;promax&quot;) par(mfrow=c(2,3)) plot(pc.extract.norotate) plot(pc.extract.varimax) plot(pc.extract.oblimin) load &lt;- ml.extract.norotate$loadings[,1:2] plot(load, type=&quot;n&quot;, main=&quot;ML + norotate&quot;) # set up the plot but don&#39;t put points down text(load, labels=rownames(load)) # put names instead of points load &lt;- ml.extract.varimax$loadings[,1:2] plot(load, type=&quot;n&quot;, main=&quot;ML + Varimax&quot;) text(load, labels=rownames(load)) load &lt;- ml.extract.promax$loadings[,1:2] plot(load, type=&quot;n&quot;, main= &quot;ML + Promax&quot;) text(load, labels=rownames(load)) Varimax vs oblique here doesn’t make much of a difference, and typically this is the case. You almost always use some sort of rotation. Recall, this is a hypothetical example and we set up the variables in a distinct two-factor model. So this example will look nice. "],
["factor-scores.html", "11.6 Factor Scores", " 11.6 Factor Scores Can be used as dependent or independent variables in other analyses Each \\(X\\) is a function of \\(F\\)’s Factor Scores are the reverse: Each \\(F\\) is a function of the \\(X\\)’s Can be generated by adding the scores=&quot;regression&quot; option to factanal(), or scores=TRUE in principal() Each record in the data set with no missing data will have a corresponding factor score. principal() also has a missing argument that if set to TRUE it will impute missing values. fa.ml.varimax &lt;- factanal(stan.dta, factors=2, rotation=&quot;varimax&quot;, scores=&quot;regression&quot;) summary(fa.ml.varimax$scores) ## Factor1 Factor2 ## Min. :-2.32732 Min. :-2.79312 ## 1st Qu.:-0.72413 1st Qu.:-0.54362 ## Median : 0.09196 Median :-0.02376 ## Mean : 0.00000 Mean : 0.00000 ## 3rd Qu.: 0.70603 3rd Qu.: 0.65339 ## Max. : 2.43371 Max. : 2.18992 head(fa.ml.varimax$scores) ## Factor1 Factor2 ## [1,] -1.49174313 0.003612941 ## [2,] -0.26254721 1.090864733 ## [3,] 0.55516045 0.631119886 ## [4,] -1.21028676 -1.281240452 ## [5,] -0.04852211 -1.575691468 ## [6,] -0.53768770 0.661138335 #library(ggforitfy) autoplot(fa.ml.varimax) # see vignette for more info. Link at bottom To merge these scores back onto the original data set providing there is no missing data you can use the bind_cols() function in dplyr. data.withscores &lt;- bind_cols(data, data.frame(fa.ml.varimax$scores)) kable(head(data.withscores)) X1 X2 X3 X4 X5 Factor1 Factor2 -0.8236763 -0.1210726 -0.5970760 -1.4752693 -1.2355056 -1.4917431 0.0036129 1.4013214 1.0733569 0.7681035 -0.0509857 0.0180061 -0.2625472 1.0908647 0.2781468 0.7574632 0.6445954 0.6765583 0.7532815 0.5551604 0.6311199 0.1819544 -1.3228227 -1.0847105 -0.9574722 -1.3719843 -1.2102868 -1.2812405 -1.6147171 -1.4254411 0.3519605 -0.0124497 -0.2523487 -0.0485221 -1.5756915 0.8251470 0.6245702 -1.2923348 -0.6345633 -0.0885945 -0.5376877 0.6611383 "],
["what-to-watch-out-for-2.html", "11.7 What to watch out for", " 11.7 What to watch out for Number of factors should be chosen with care. Check default options. There should be at least two variables with non-zero weights per factor If the factors are to be correlated, try oblique factor analysis Results usually are evaluated by reasonableness to investigator rather than by formal tests Motivate theory, not replace it. Missing data - factors will only be created using available data. "],
["help.html", "11.8 Additional Resources", " 11.8 Additional Resources A gentle non-technical introduction to factor analysis Tutorial by a Psych 253 student at Stanford https://web.stanford.edu/class/psych253/tutorials/FactorAnalysis.html ggfortify vignette for the autoplot() function https://cran.r-project.org/web/packages/ggfortify/vignettes/plot_pca.html The FactomineR looks promising, it has some helpful graphics for determining/confirming variable groupings and aiding interpretations. However it looks more like for CFA - when you know the theoretical groupings. FactominR: http://factominer.free.fr/ STHDA tutorial using FactominR http://www.sthda.com/english/articles/31-principal-component-methods-in-r-practical-guide/116-mfa-multiple-factor-analysis-in-r-essentials/ "],
["mda.html", "Chapter 12 Missing Data", " Chapter 12 Missing Data Missing Data happens. Not always General: Item non-response. Individual pieces of data are missing. Unit non-response: Records have some background data on all units, but some units don’t respond to any question. Monotonone missing data: Variables can be ordered such that one block of variables more observed than the next. "],
["identifying-missing-data.html", "12.1 Identifying missing data", " 12.1 Identifying missing data Missing data in R is denoted as NA Arithmetic functions on missing data will return missing survey &lt;- MASS::survey # to avoid loading the MASS library which will conflict with dplyr head(survey$Pulse) ## [1] 92 104 87 NA 35 64 mean(survey$Pulse) ## [1] NA The summary() function will always show missing. summary(survey$Pulse) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 35.00 66.00 72.50 74.15 80.00 104.00 45 The is.na() function is helpful to identify rows with missing data table(is.na(survey$Pulse)) ## ## FALSE TRUE ## 192 45 The function table() will not show NA by default. table(survey$M.I) ## ## Imperial Metric ## 68 141 table(survey$M.I, useNA=&quot;always&quot;) ## ## Imperial Metric &lt;NA&gt; ## 68 141 28 What percent of the data set is missing? round(prop.table(table(is.na(survey)))*100,1) ## ## FALSE TRUE ## 96.2 3.8 4% of the data points are missing. How much missing is there per variable? prop.miss &lt;- apply(survey, 2, function(x) round(sum(is.na(x))/NROW(x),4)) prop.miss ## Sex Wr.Hnd NW.Hnd W.Hnd Fold Pulse Clap Exer Smoke Height ## 0.0042 0.0042 0.0042 0.0042 0.0000 0.1899 0.0042 0.0000 0.0042 0.1181 ## M.I Age ## 0.1181 0.0000 The amount of missing data per variable varies from 0 to 19%. 12.1.1 Visualize missing patterns Using ggplot2 pmpv &lt;- data.frame(variable = names(survey), pct.miss =prop.miss) ggplot(pmpv, aes(x=variable, y=pct.miss)) + geom_bar(stat=&quot;identity&quot;) + ylab(&quot;Percent&quot;) + scale_y_continuous(labels=scales::percent, limits=c(0,1)) + geom_text(data=pmpv, aes(label=paste0(round(pct.miss*100,1),&quot;%&quot;), y=pct.miss+.025), size=4) Using mice library(mice) md.pattern(survey) ## Fold Exer Age Sex Wr.Hnd NW.Hnd W.Hnd Clap Smoke Height M.I Pulse ## 168 1 1 1 1 1 1 1 1 1 1 1 1 0 ## 1 1 1 1 0 1 1 1 1 1 1 1 1 1 ## 1 1 1 1 1 1 1 0 1 1 1 1 1 1 ## 38 1 1 1 1 1 1 1 1 1 1 1 0 1 ## 20 1 1 1 1 1 1 1 1 1 0 0 1 2 ## 1 1 1 1 1 0 0 1 0 1 1 1 1 3 ## 7 1 1 1 1 1 1 1 1 1 0 0 0 3 ## 1 1 1 1 1 1 1 1 1 0 0 0 1 3 ## 0 0 0 1 1 1 1 1 1 28 28 45 107 This somewhat ugly output tells us that 168 records have no missing data, 38 records are missing only Pulse and 20 are missing both Height and M.I. Using VIM library(VIM) aggr(survey, col=c(&#39;chartreuse3&#39;,&#39;mediumvioletred&#39;), numbers=TRUE, sortVars=TRUE, labels=names(survey), cex.axis=.7, gap=3, ylab=c(&quot;Missing data&quot;,&quot;Pattern&quot;)) The plot on the left is a simplified, and ordered version of the ggplot from above, except the bars appear to be inflated because the y-axis goes up to 15% instead of 100%. The plot on the right shows the missing data patterns, and indicate that 71% of the records has complete cases, and that everyone who is missing M.I. is also missing Height. Another plot that can be helpful to identify patterns of missing data is a marginplot (also from VIM). Two continuous variables are plotted against each other. Blue bivariate scatterplot and univariate boxplots are for the observations where values on both variables are observed. Red univariate dotplots and boxplots are drawn for the data that is only observed on one of the two variables in question. The darkred text indicates how many records are missing on both. marginplot(survey[,c(6,10)]) This shows us that the observations missing pulse have the same median height, but those missing height have a higher median pulse rate. "],
["effects-of-nonresponse.html", "12.2 Effects of Nonresponse", " 12.2 Effects of Nonresponse Textbook example: Example reported in W.G. Cochran, Sampling Techniques, 3rd edition, 1977, ch. 13 Consider data that come form an experimental sampling of fruit orcharts in North Carolina in 1946. Three successive mailings of the same questionnaire were sent to growers. For one of the questions the number of fruit trees, complete data were available for the population… Ave. # trees # of growers % of pop’n Ave # trees/grower 1st mailing responders 300 10 456 2nd mailing responders 543 17 382 3rd mailing responders 434 14 340 Nonresponders 1839 59 290 ——– ——– ——– Total population 3116 100 329 The overall response rate was very low. The rate of non response is clearly related to the average number of trees per grower. The estimate of the average trees per grower can be calculated as a weighted average from responders \\(\\bar{Y_{1}}\\) and non responders \\(\\bar{Y_{2}}\\). Bias: The difference between the observed estimate \\(\\bar{y}_{1}\\) and the true parameter \\(\\mu\\). \\[ \\begin{aligned} E(\\bar{y}_{1}) - \\mu &amp; = \\bar{Y_{1}} - \\bar{Y} \\\\ &amp; = \\bar{Y}_{1} - \\left[(1-w)\\bar{Y}_{1} - w\\bar{Y}_{2}\\right] \\\\ &amp; = w(\\bar{Y}_{1} - \\bar{Y}_{2}) \\end{aligned} \\] Where \\(w\\) is the proportion of non-response. The amount of bias is the product of the proportion of non-response and the difference in the means between the responders and the non-responders. The sample provides no information about \\(\\bar{Y_{2}}\\), the size of the bias is generally unknown without information gained from external data. "],
["missing-data-mechanisms.html", "12.3 Missing Data Mechanisms", " 12.3 Missing Data Mechanisms Process by which some units observed, some units not observed Missing Completely at Random (MCAR): The probability that a data point is missing is completely unrelated (independent) of any observed and unobserved data or parameters. P(Y missing| X, Y) = P(Y missing) Ex: Miscoding or forgetting to log in answer Missing at Random (MAR): The probability that a data point is missing is independent can be explained or modeled by other observed variables. P(Y missing|x, Y) = P(Y missing | X) Ex: Y = age, X = sex - Pr (Y miss| X = male) = 0.2 - Pr (Y miss| X = female) = 0.3 - Males people are less likely to fill out an income survey - The missing data on income is related to gender - After accounting for gender the missing data is unrelated to income. Not missing at Random (NMAR): The probability that a data point is missing depends on the value of the variable in question. P(Y missing | X, Y) = P (Y missing|X, Y) Ex: Y = income, X = immigration status Richer person may be less willing to disclose income Undocumented immigrant may be less willing to disclose income Write down an example of each. Does it matter to inferences? Yes! 12.3.1 Demonstration via Simulation What follows is just one method of approaching this problem via code. Simulation is a frequently used technique to understand the behavior of a process over time or over repeated samples. 12.3.1.1 MCAR Draw a random sample of size 100 from a standard Normal distribution (Z) and calculate the mean. set.seed(456) # setting a seed ensures the same numbers will be drawn each time z &lt;- rnorm(100) mean.z &lt;- mean(z) mean.z ## [1] 0.1205748 Delete data at a rate of \\(p\\) and calculate the complete case (available) mean. Sample 100 random Bernoulli (0/1) variables with probability \\(p\\). x &lt;- rbinom(100, 1, p=.5) Find out which elements are are 1’s delete.these &lt;- which(x==1) Set those elements in z to NA. z[delete.these] &lt;- NA Calculate the complete case mean mean(z, na.rm=TRUE) ## [1] 0.1377305 Calculate the bias as the sample mean minus the true mean (\\(E(\\hat\\theta) - \\theta\\)). mean(z, na.rm=TRUE) - mean.z ## [1] 0.01715565 How does the bias change as a function of the proportion of missing? Let \\(p\\) range from 0% to 99% and plot the bias as a function of \\(p\\). calc.bias &lt;- function(p){ # create a function to handle the repeated calculations mean(ifelse(rbinom(100, 1, p)==1, NA, z), na.rm=TRUE) - mean.z } p &lt;- seq(0,.99,by=.01) plot(c(0,1), c(-1, 1), type=&quot;n&quot;, ylab=&quot;Bias&quot;, xlab=&quot;Proportion of missing&quot;) points(p, sapply(p, calc.bias), pch=16) abline(h=0, lty=2, col=&quot;blue&quot;) What is the behavior of the bias as \\(p\\) increases? Look specifically at the position/location of the bias, and the variance/variability of the bias. 12.3.1.2 NMAR: Missing related to data What if the rate of missing is related to the value of the outcome? Again, let’s setup a simulation to see how this works. Randomly draw 100 random data points from a Standard Normal distribution to serve as our population, and 100 uniform random values between 0 and 1 to serve as probabilities of the data being missing (\\(p=P(miss)\\)) Z &lt;- rnorm(100) p &lt;- runif(100, 0, 1) Sort both in ascending order, shove into a data frame and confirm that \\(p(miss)\\) increases along with \\(z\\). dta &lt;- data.frame(Z=sort(Z), p=sort(p)) head(dta) ## Z p ## 1 -2.898122 0.003673455 ## 2 -2.185058 0.013886146 ## 3 -2.076032 0.035447986 ## 4 -1.938288 0.039780643 ## 5 -1.930809 0.051362816 ## 6 -1.905331 0.054639596 ggplot(dta, aes(x=p, y=Z)) + geom_point() + xlab(&quot;P(missing)&quot;) + ylab(&quot;Z~Normal(0,1)&quot;) Set \\(Z\\) missing with probability equal to the \\(p\\) for that row. Create a new vector dta$z.miss that is either 0, or the value of dta$Z with probability 1-dta$p. Then change all the 0’s to NA. dta$Z.miss &lt;- dta$Z * (1-rbinom(NROW(dta), 1, dta$p)) head(dta) # see structure of data to understand what is going on ## Z p Z.miss ## 1 -2.898122 0.003673455 -2.898122 ## 2 -2.185058 0.013886146 -2.185058 ## 3 -2.076032 0.035447986 -2.076032 ## 4 -1.938288 0.039780643 -1.938288 ## 5 -1.930809 0.051362816 -1.930809 ## 6 -1.905331 0.054639596 -1.905331 dta$Z.miss[dta$Z.miss==0] &lt;- NA Calculate the complete case mean and the bias mean(dta$Z.miss, na.rm=TRUE) ## [1] -0.7777319 mean(dta$Z) - mean(dta$Z.miss, na.rm=TRUE) ## [1] 0.6830372 Did the complete case estimate over- or under-estimate the true mean? Is the bias positive or negative? 12.3.1.3 NMAR: Pure Censoring Consider a hypothetical blood test to measure a hormone that is normally distributed in the blood with mean 10\\(\\mu g\\) and variance 1. However the test to detect the compound only can detect levels above 10. z &lt;- rnorm(100, 10, 1) y &lt;- z y[y&lt;10] &lt;- NA mean(z) - mean(y, na.rm=TRUE) ## [1] -0.6850601 Did the complete case estimate over- or under-estimate the true mean? When the data is not missing at random, the bias can be much greater. Usually you don’t know the missing data mechanism. Degrees of difficulty MCAR: is easiest to deal with. MAR: we can live with it. NMAR: most difficult to handle. Evidence? What can we learn from evidence in the data set at hand? May be evidence in the data rule out MCAR - test responders vs. nonresponders. Example: Responders tend to have higher/lower average education than nonresponders by t-test Example: Response more likely in one geographic area than another by chi-square test No evidence in data set to rule out MAR (although there may be evidence from an external data source) What is plausible? Cochran example: when human behavior is involved, MCAR must be viewed as an extremely special case that would often be violated in practice Missing data may be introduced by design (e.g., measure some variables, don’t measure others for reasons of cost, response burden), in which case MCAR would apply MAR is much more common than MCAR We cannot be too cavalier about assuming MAR, but anecdotal evidence shows that it often is plausible when conditioning on enough information Ignorable Missing If missing-data mechanism is MCAR or MAR then nonresponse is said to be “ignorable”. Origin of name: in likelihood-based inference, both the data model and missing-data mechanism are important but with MCAR or MAR, inference can be based solely on the data model, thus making inference much simpler “Ignorability” is a relative assumption: missingness on income may be NMAR given only gender, but may be MAR given gender, age, occupation, region of the country "],
["general-strategies.html", "12.4 General strategies", " 12.4 General strategies Strategies for handling missing data include: Complete-case/available-case analysis: drop cases that make analysis inconvenient. If variables are known to contribute to the missing values, then appropriate modeling can often account for the missingness. Imputation procedures: fill in missing values, then analyze completed data sets using complete-date methods Weighting procedures: modify “design weights” (i.e., inverse probabilities of selection from sampling plan) to account for probability of response Model-based approaches: develop model for partially missing data, base inferences on likelihood under that model 12.4.1 Complete cases analysis If not all variables observed, delete case from analysis Advantages: Simplicity Common sample for all estimates Disadvantages: Loss of valid information Bias due to violation of MCAR 12.4.2 Available-case analysis Use all cases where the variable of interest is present Potentially different sets of cases for means of X and Y and complete pairs for \\(r_{XY}\\) Tempting to think that available-case analysis will be superior to complete-case analysis But it can distort relationships between variables by not using a common base of observations for all quantities being estimated. 12.4.3 Imputation Fill in missing values, analyze completed data set Advantage: Rectangular data set easier to analyze Disadvantage: “Both seductive and dangerous” (Little and Rubin) Can understate uncertainty due to missing values. Can induce bias if imputing under the wrong model. "],
["imputation-methods.html", "12.5 Imputation Methods", " 12.5 Imputation Methods Unconditional mean substitution. Never use Impute all missing data using the mean of observed cases Artificially decreases the variance. Hot deck imputation Impute values by randomly sampling values from observed data. Good for categorical data Reasonable for MCAR and MAR Model based imputation Conditional Mean imputation: Use regression on observed variables to estimate missing values Predictive Mean Matching: Fills in a value randomly by sampling observed values whose regression-predicted values are closest to the regression-predicted value for the missing point. Cross between hot-deck and conditional mean Categorical data can be imputed using classification models Less biased than mean substitution but SE’s could be inflated Adding a residual Impute regression value \\(\\pm\\) a randomly selected residual based on estimated residual variance Over the long-term, we can reduce bias, on the average …but we can do better. "],
["multiple-imputation-mi.html", "12.6 Multiple Imputation (MI)", " 12.6 Multiple Imputation (MI) 12.6.1 Goals Accurately reflect available information Avoid bias in estimates of quantities of interest Estimation could involve explicit or implicit model Accurately reflect uncertainty due to missingness 12.6.2 Technique For each missing value, impute \\(m\\) estimates (usually \\(m\\) = 5) Imputation method must include a random component Create \\(m\\) complete data sets Perform desired analysis on each of the \\(m\\) complete data sets Combine final estimates in a manner that accounts for the between, and within imputation variance. _Credit: http://www.stefvanbuuren.nl_ 12.6.3 MI as a paradigm Logic: “Average over” uncertainty, don’t assume most likely scenario (single imputation) covers all plausible scenarios Principle: Want nominal 95% intervals to cover targets of estimation 95% of the time Simulation studies show that, when MAR assumption holds: Proper imputations will yield close to nominal coverage (Rubin 87) Improvement over single imputation is meaningful Number of imputations can be modest - even 2 adequate for many purposes, so 5 is plenty Rubin 87: Multiple Imputation for Nonresponse in Surveys, Wiley, 1987). 12.6.4 Inference on MI Consider \\(m\\) imputed data sets. For some quantity of interest \\(Q\\) with squared \\(SE = U\\), calculate \\(Q_{1}, Q_{2}, \\ldots, Q_{m}\\) and \\(U_{1}, U_{2}, \\ldots, U_{m}\\) (e.g., carry out \\(m\\) regression analyses, obtain point estimates and SE from each). Then calculate the average estimate \\(\\bar{Q}\\), the average variance \\(\\bar{U}\\), and the variance of the averages \\(B\\). \\[ \\begin{aligned} \\bar{Q} &amp; = \\sum^{m}_{i=1}Q_{i}/m \\\\ \\bar{U} &amp; = \\sum^{m}_{i=1}U_{i}/m \\\\ B &amp; = \\frac{1}{m-1}\\sum^{m}_{i=1}(Q_{i}-\\bar{Q})^2 \\end{aligned} \\] Then \\(T = \\bar{U} + \\frac{m+1}{m}B\\) is the estimated total variance of \\(\\bar{Q}\\). Significance tests and interval estimates can be based on \\[\\frac{\\bar{Q}-Q}{\\sqrt{T}} \\sim t_{df}, \\mbox{ where } df = (m-1)(1+\\frac{1}{m+1}\\frac{\\bar{U}}{B})^2\\] df are similar to those for comparison of normal means with unequal variances, i.e., using Satterthwaite approximation. Ratio of (B = between-imputation variance) to (T = between + within-imputation variance) is known as the fraction of missing information (FMI). The FMI has been proposed as a way to monitor ongoing data collection and estimate the potential bias resulting from survey non-responders Wagner, 2018 "],
["multiple-imputation-using-chained-equations-mice.html", "12.7 Multiple Imputation using Chained Equations (MICE)", " 12.7 Multiple Imputation using Chained Equations (MICE) 12.7.1 Overview Generates multiple imputations for incomplete multivariate data by Gibbs sampling. Missing data can occur anywhere in the data. Impute an incomplete column by generating ‘plausible’ synthetic values given other columns in the data. For predictors that are incomplete themselves, the most recently generated imputations are used to complete the predictors prior to imputation of the target column. A separate univariate imputation model can be specified for each column. The default imputation method depends on the measurement level of the target column. Your best reference guide to this section of the notes is the mice: Multivariate Imputation by Chained Equations in R article in the Journal of Statistical Software by Stef van Buuren. https://www.jstatsoft.org/article/view/v045i03 12.7.2 Process / Algorithm Consider a data matrix with 3 variables \\(y_{1}\\), \\(y_{2}\\), \\(y_{3}\\), each with missing values. At iteration \\((\\ell)\\): Fit a model on \\(y_{1}^{(\\ell-1)}\\) using current values of \\(y_{2}^{(\\ell-1)}, y_{3}^{(\\ell-1)}\\) Impute missing \\(y_{1}\\), generating \\(y_{1}^{(\\ell)}\\) Fit a model on \\(y_{2}^{(\\ell-1)}\\) using current versions of \\(y_{1}^{(\\ell)}, y_{3}^{(\\ell-1)}\\) Impute missing \\(y_{2}\\), generating \\(y_{2}^{(\\ell)}\\) Fit a model on \\(y_{3}\\) using current versions of \\(y_{1}^{(\\ell)}, y_{2}^{(\\ell)}\\) Impute missing \\(y_{3}\\), generating \\(y_{3}^{(\\ell)}\\) Start next cycle using updated values \\(y_{1}^{(\\ell)}, y_{2}^{(\\ell)}, y_{3}^{(\\ell)}\\) where \\((\\ell)\\) cycles from 1 to \\(L\\), before an imputed value is drawn. 12.7.3 Convergence How many imputations (\\(m\\)) should we create and how many iterations (\\(L\\)) should I run between imputations? Original research from Rubin states that small amount of imputations (\\(m=5\\)) would be sufficient. Advances in computation have resulted in very efficient programs such as mice - so generating a larger number of imputations (say \\(m=40\\)) are more common Pan, 2016 You want the number of iterations between draws to be long enough that the Gibbs sampler has converged. There is no test or direct method for determing convergence. Plot parameter against iteration number, one line per chain. These lines should be intertwined together, without showing trends. Convergence can be identified when the variance between lines is smaller (or at least no larger) than the variance within the lines. Mandatory Reading Read 4.3: Assessing Convergence in the JSS article on mice 12.7.4 Imputation Methods Some built-in imputation methods in the mice package are: pmm: Predictive mean matching (any) DEFAULT FOR NUMERIC norm.predict: Linear regression, predicted values (numeric) mean: Unconditional mean imputation (numeric) logreg: Logistic regression (factor, 2 levels) DEFAULT logreg.boot: Logistic regression with bootstrap polyreg: Polytomous logistic regression (factor, &gt;= 2 levels) DEFAULT lda: Linear discriminant analysis (factor, &gt;= 2 categories) cart: Classification and regression trees (any) rf: Random forest imputations (any) "],
["example-prescribed-amount-of-missing-.html", "12.8 Example: Prescribed amount of missing.", " 12.8 Example: Prescribed amount of missing. We will demonstrate using Fisher’s Iris data (pre-built in with R) where we can artificially create a prespecified percent of the data missing. This allows us to be able to estimate the bias incurred by using these imputation methods. For the iris data we set a seed and use the prodNA() function from the missForest package to create 10% missing values in this data set. library(missForest) set.seed(12345) # Note to self: Change the combo on my luggage iris.mis &lt;- prodNA(iris, noNA=0.1) prop.table(table(is.na(iris.mis))) ## ## FALSE TRUE ## 0.9 0.1 Visualize missing data pattern. library(VIM) aggr(iris.mis, col=c(&#39;darkolivegreen3&#39;,&#39;salmon&#39;), numbers=TRUE, sortVars=TRUE, labels=names(iris.mis), cex.axis=.7, gap=3, ylab=c(&quot;Missing data&quot;,&quot;Pattern&quot;)) ## ## Variables sorted by number of missings: ## Variable Count ## Sepal.Length 0.10666667 ## Petal.Width 0.10666667 ## Sepal.Width 0.10000000 ## Species 0.10000000 ## Petal.Length 0.08666667 Here’s another example of where only 10% of the data overall is missing, but it results in only 58% complete cases. 12.8.1 Multiply impute the missing data using mice() imp_iris &lt;- mice(iris.mis, m=10, maxit=25, meth=&quot;pmm&quot;, seed=500, printFlag=FALSE) summary(imp_iris) ## Multiply imputed data set ## Call: ## mice(data = iris.mis, m = 10, method = &quot;pmm&quot;, maxit = 25, printFlag = FALSE, ## seed = 500) ## Number of multiple imputations: 10 ## Missing cells per column: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 16 15 13 16 15 ## Imputation methods: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; ## VisitSequence: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 2 3 4 5 ## PredictorMatrix: ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## Sepal.Length 0 1 1 1 1 ## Sepal.Width 1 0 1 1 1 ## Petal.Length 1 1 0 1 1 ## Petal.Width 1 1 1 0 1 ## Species 1 1 1 1 0 ## Random generator seed value: 500 The Stack Exchange post listed below has a great explanation/description of what each of these arguments control. It is a very good idea to understand these controls. https://stats.stackexchange.com/questions/219013/how-do-the-number-of-imputations-the-maximum-iterations-affect-accuracy-in-mul/219049#219049 12.8.2 Check the imputation method used on each variable. imp_iris$meth ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; &quot;pmm&quot; Predictive mean matching was used for all variables, even Species. This is reasonable because PMM is a hot deck method of imputation. 12.8.3 Check Convergence plot(imp_iris, c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;, &quot;Petal.Length&quot;)) The variance across chains is no larger than the variance within chains. 12.8.4 Look at the values generated for imputation imp_iris$imp$Sepal.Length ## 1 2 3 4 5 6 7 8 9 10 ## 1 5.0 5.0 5.0 5.8 5.0 5.0 5.5 5.0 5.0 4.9 ## 5 5.1 5.0 4.9 4.9 5.8 5.1 4.8 4.7 5.1 5.3 ## 26 4.9 5.1 5.0 5.0 5.0 4.6 5.1 4.6 4.9 5.1 ## 31 5.1 4.7 5.0 4.9 5.2 4.6 4.6 5.0 4.6 5.0 ## 33 5.2 5.5 6.0 4.9 5.5 5.5 5.5 5.6 5.7 5.7 ## 39 4.4 5.0 4.3 5.0 4.4 5.0 4.4 4.4 4.4 4.9 ## 43 4.7 5.4 4.9 4.9 4.6 4.6 4.9 4.7 4.8 4.6 ## 56 5.8 5.6 6.1 5.4 5.4 5.5 6.2 6.0 5.8 5.8 ## 96 5.8 6.3 5.6 6.5 6.2 6.2 5.8 6.5 6.4 6.6 ## 103 6.5 6.9 6.7 6.8 6.7 7.2 7.4 7.2 6.7 6.8 ## 113 6.3 6.7 6.7 6.7 6.7 6.7 6.7 6.7 6.4 5.9 ## 124 5.7 5.8 6.2 6.1 5.5 6.6 6.2 6.2 6.2 5.5 ## 132 7.7 7.7 7.7 7.7 7.7 7.7 7.6 7.6 7.7 7.3 ## 135 6.0 6.4 6.3 6.7 6.7 6.5 6.3 6.4 7.0 5.6 ## 149 6.4 6.5 6.8 7.0 7.0 6.4 6.3 6.3 6.5 6.3 ## 150 6.4 6.1 6.4 6.4 6.3 6.5 6.4 6.1 6.4 6.4 This is just for us to see what this imputed data look like. Each column is an imputed value, each row is a row where an imputation for Sepal.Length was needed. Notice only imputations are shown, no observed data is showing here. 12.8.5 Create a complete data set by filling in the missing data using the imputations iris_1 &lt;- complete(imp_iris, action=1) Action=1 returns the first completed data set, action=2 returns the second completed data set, and so on. 12.8.5.1 Alternative - Stack the imputed data sets in long format. iris_long &lt;- complete(imp_iris, &#39;long&#39;) By looking at the names of this new object we can confirm that there are indeed 10 complete data sets with \\(n=150\\) in each. names(iris_long) ## [1] &quot;.imp&quot; &quot;.id&quot; &quot;Sepal.Length&quot; &quot;Sepal.Width&quot; ## [5] &quot;Petal.Length&quot; &quot;Petal.Width&quot; &quot;Species&quot; table(iris_long$.imp) ## ## 1 2 3 4 5 6 7 8 9 10 ## 150 150 150 150 150 150 150 150 150 150 12.8.6 Visualize Imputations Let’s compare the imputed values to the observed values to see if they are indeed “plausible” We want to see that the distribution of of the magenta points (imputed) matches the distribution of the blue ones (observed). Univariately densityplot(imp_iris) Multivariately xyplot(imp_iris, Sepal.Length ~ Sepal.Width + Petal.Length + Petal.Width | Species, cex=.8, pch=16) Analyze and pool All of this imputation was done so we could actually perform an analysis! Let’s run a simple linear regression on Sepal.Length as a function of Sepal.Width, Petal.Length and Species. model &lt;- with(imp_iris, lm(Sepal.Length ~ Sepal.Width + Petal.Length + Species)) summary(pool(model)) ## est se t df Pr(&gt;|t|) ## (Intercept) 2.4003660 0.27904211 8.602164 117.11666 4.107825e-14 ## Sepal.Width 0.4635384 0.08556538 5.417359 122.66722 3.066295e-07 ## Petal.Length 0.7126897 0.07046809 10.113652 87.37099 2.220446e-16 ## Species2 -0.7875803 0.23149303 -3.402177 100.83240 9.597852e-04 ## Species3 -1.1614620 0.32513199 -3.572279 69.21508 6.493711e-04 ## lo 95 hi 95 nmis fmi lambda ## (Intercept) 1.8477435 2.9529885 NA 0.10362235 0.08844452 ## Sepal.Width 0.2941624 0.6329144 15 0.08849659 0.07375537 ## Petal.Length 0.5726351 0.8527443 13 0.18448110 0.16602439 ## Species2 -1.2468094 -0.3283511 NA 0.14686085 0.13010510 ## Species3 -1.8100466 -0.5128774 NA 0.24332027 0.22176707 Pooled parameter estimates \\(\\bar{Q}\\) and their standard errors \\(\\sqrt{T}\\) are provided, along with a significance test (against \\(\\beta_p=0\\)), and a 95% interval. Additional information included in this table is the number of missing values, the fraction of missing information (fmi) as defined by Rubin (1987), and lambda, the proportion of total variance that is attributable to the missing data (\\(\\lambda = (B + B/m)/T)\\). kable(summary(pool(model))[,c(1:3, 5:7, 9)], digits=3) est se t Pr(&gt;|t|) lo 95 hi 95 fmi (Intercept) 2.400 0.279 8.602 0.000 1.848 2.953 0.104 Sepal.Width 0.464 0.086 5.417 0.000 0.294 0.633 0.088 Petal.Length 0.713 0.070 10.114 0.000 0.573 0.853 0.184 Species2 -0.788 0.231 -3.402 0.001 -1.247 -0.328 0.147 Species3 -1.161 0.325 -3.572 0.001 -1.810 -0.513 0.243 12.8.7 Calculating bias The iris data set had no missing data to begin with. So we can calculate the “true” parameter estimates… true.model &lt;- lm(Sepal.Length ~ Sepal.Width + Petal.Length + Species, data=iris) and find the difference in coefficients. The variance of the multiply imputed estimates is larger because of the between-imputation variance. library(forestplot) te.mean &lt;- summary(true.model)$coefficients[,1] mi.mean &lt;- summary(pool(model))[,1] te.ll &lt;- te.mean - 1.96*summary(true.model)$coefficients[,2] mi.ll &lt;- summary(pool(model))[,6] te.ul &lt;- te.mean + 1.96*summary(true.model)$coefficients[,2] mi.ul &lt;- summary(pool(model))[,7] names &lt;- names(coef(true.model)) forestplot(names, legend = c(&quot;True Model&quot;, &quot;MICE&quot;), fn.ci_norm = c(fpDrawNormalCI, fpDrawCircleCI), mean = cbind(te.mean, mi.mean), lower = cbind(te.ll, mi.ll), upper = cbind(te.ul, mi.ul), col=fpColors(box=c(&quot;blue&quot;, &quot;darkred&quot;)), xlab=&quot;Regression coefficients&quot;, boxsize = .1 ) "],
["final-thoughts.html", "12.9 Final thoughts", " 12.9 Final thoughts “In our experience with real and artificial data…, the practical conclusion appears to be that multiple imputation, when carefully done, can be safely used with real problems even when the ultimate user may be applying models or analyses not contemplated by the imputer.” - Little &amp; Rubin (Book, p. 218) Don’t ignore missing data. Impute sensibly and multiple times. It’s typically desirable to include many predictors in an imputation model, both to improve precision of imputed values make MAR assumption more plausible But the number of covariance parameters goes up as the square of the number of variables in the model, implying practical limits on the number of variables for which parameters can be estimated well MI applies to subjects who have a general missingness pattern, i.e., they have measurements on some variables, but not on others. But, subjects can be lost to follow up due to death or other reasons (i.e., attrition). Here we have only baseline data, but not the outcome or other follow up data. If attrition subjects are eliminated from the sample, they can produce non-response or attrition bias. Use attrition weights. Given a baseline profile, predict the probability that subject will stay and use the inverse probability as weight. e.g., if for a given profile all subjects stay, then the predicted probability is 1 and the attrition weight is 1. Such a subject “counts once”. For another profile, the probability may be 0.5, attrition weight is 1/.5 = 2 and that person “counts twice”. For differential drop-out, or self-selected treatment, you can consider using Propensity Scores. "],
["additional-references-1.html", "12.10 Additional References", " 12.10 Additional References Little, R. and Rubin, D. Statistical Analysis with Missing Data, 2nd Ed., Wiley, 2002 Standard reference Requires some math Allison, P. Missing Data, Sage, 2001 Small and cheap Requires very little math Multiple Imputation.com http://www.stefvanbuuren.nl/mi/ http://www.analyticsvidhya.com/blog/2016/03/tutorial-powerful-packages-imputing-missing-values/ http://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/ Imputation methods for complex survey data and data not missing at random is an open research topic. Read more about this here: https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_mi_sect032.htm https://shirinsplayground.netlify.com/2017/11/mice_sketchnotes/ "]
]
