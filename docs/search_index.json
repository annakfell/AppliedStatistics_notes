[["data_prep.html", "Chapter 1 Workflow and Data Cleaning", " Chapter 1 Workflow and Data Cleaning Once the data are available from a study there are still a number of steps that must be undertaken to get them into shape for analysis. One of the most misunderstood parts of the analysis process is the data preparation stage. To say that 70% of any analysis is spent on the data management stage is not an understatement. This chapter provides information on topics related to data processing and corresponds to :book: PMA6 Chapter 3. "],["generating-a-reproducible-workflows.html", "1.1 Generating a reproducible workflows", " 1.1 Generating a reproducible workflows Reproducibility is the ability for any researcher to take the same data set and run the same set of software program instructions as another researcher and achieve the same results. The goal is to create an exact record of what was done to a data set to produce a specific result. To achieve reproducibility, we believe that three things must be present: The un-processed data are connected directly to software code file(s) that perform data preparation techniques. The processed data are connected directly to other software code file(s) that perform the analyses. All data and code files are self-contained such that they could be given to another researcher to execute the code commands on a separate computer and achieve the same results as the original author. PrepareData Why do we need a codebook? You are your own collaborator 6 months from now. Make sure you will be able to understand what you were doing. Investing the time to do things clearly and in a reproducible manner will make your future self happy. Comment your code with explanations and instructions. How did you get from point A to B? Why did you recode this variable in this manner? We need to record those steps (not just for posterity). This means your code must be saved in a script file. Include sufficient notes to yourself describing what you are doing and why. For R, this can be in a .R or .RMD file. I always prefer the latter. For SPSS you can specify to paste the syntax and copy into a .sps script file. For SAS you’ll use a .sas file For STATA this will be a .do file Repro Figure Credits: Roger Peng 1.1.1 Literate programming Programming paradigm introduced by Knuth (1984) Explain the logic of the program or analysis process in a natural language, Small code snippets included at each step act as a full set of instructions that can be executed to reproduce the result/analysis being discussed. Literate programming tools are integrated into most common statistical packages Markdown (R, Stata) \\(\\LaTeX\\) (R, SAS, Stata) 1.1.2 Reproducible Research + Literate Programming Practicing reproducible research techniques using literate programming tools allows such major updates to be a simple matter of re-compiling all coded instructions using the updated data set. The effort then is reduced to a careful review and update of any written results. Using literate programming tools create formatted documents section headers bold and italicized words tables and graphics with built-in captions in a streamlined manner that is fully synchronized with the code itself. The author writes the text explanations, interpretations, and code in the statistical software program itself, and the program will execute all commands and combine the text, code and output all together into a final dynamic document. What stages of the pipeline shown above can we conduct using literate programming tools? "],["import-data.html", "1.2 Import data", " 1.2 Import data This section uses the raw depression data set from the Afifi et.al. textbook. library(ggplot2) depress &lt;- read.table(&quot;https://norcalbiostat.netlify.com/data/Depress.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) SPSS syntax will look similar like this: GET DATA /TYPE=XLSX /FILE=&#39;C:\\path\\to\\file.xlsx&#39; /SHEET=name &#39;Name-of-Sheet&#39; /CELLRANGE=full /READNAMES=on /ASSUMEDSTRWIDTH=32767. EXECUTE. DATASET NAME DataSetExcel WINDOW=FRONT. Reference on importing data into SPSS: https://libguides.library.kent.edu/SPSS/ImportData. The absolute first thing you should do is to look at your raw data table. Are the column headers variable names? Did all the rows get read in? Are there any extra columns or rows included? 1.2.1 Renaming variable names for sanity sake Turn all variable names to lower case. This is especially frustrating for R and STATA users where syntax is case sensitive. This is completely optional but helpful names(depress) &lt;- tolower(names(depress)) You should also rename any variable that has spaces or special characters in the name. "],["data-management.html", "1.3 Data Management", " 1.3 Data Management Questions to ask yourself (and the data) while reviewing the codebook to choose variables to be used in an analysis. Do you need to code out missing data? Missing values sometimes are recorded as something like MISSING or -99? Do you need to make response codes more logical? Some systems will record 1=YES and 2=NO. This should be changed to 0=NO. Do you need to recode numerical variables to categorical? Sometimes categorical data will be recorded as 1, 2, 3 etc when those numbers represent named categories. Do you need to create secondary variables? Such as an average across measures to create a score. Some of these answers will come only after you look at your data. This can be looking at the raw data itself but also looking at tables and charts generated from the data. Often when you try to create a plot or table you will encounter an error or something odd looking that will be the notification that something has to be adjusted. Let’s look at a few of the common data management processes. 1.3.1 Missing data In Excel, missing data can show up as a blank cell. In SPSS it is represented as a . period. R displays missing data as NA values. Missing Data in SPSS: https://stats.idre.ucla.edu/spss/modules/missing-data/ Why would data be missing? Other than the obvious data entry errors, tech glitches or just non-cooperative plants or people, sometimes values are out of range and you would rather delete them than change their value (data edit). Lets look at the religion variable in the depression data set. table(depress$relig, useNA=&quot;always&quot;) ## ## 1 2 3 4 6 &lt;NA&gt; ## 155 51 30 56 2 0 Looking at the codebook, there is no category 6 for religion. Let’s change all values to NA. depress$relig[depress$relig==6] &lt;- NA This code says take all rows where relig is equal to 6, and change them to NA. Confirm recode. table(depress$relig, useNA=&quot;always&quot;) ## ## 1 2 3 4 &lt;NA&gt; ## 155 51 30 56 2 Notice the use of the useNA=\"always\" argument. If we just looked at the base table without this argument, we would have never known there was missing data! table(depress$relig) ## ## 1 2 3 4 ## 155 51 30 56 What about continuous variables? Well there happens to be no other missing data in this data set, so let’s make up a set of 7 data points stored in a variable named y. y &lt;- c(1, 2, 3, NA, 4, NA, 6) y ## [1] 1 2 3 NA 4 NA 6 The #1 way to identify missing data in a continuous variable is by looking at the summary() values. mean(y) ## [1] NA summary(y) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 1.0 2.0 3.0 3.2 4.0 6.0 2 mean(y, na.rm=TRUE) ## [1] 3.2 In R, any arithmetic function (like addition, multiplication) on missing data results in a missing value. The na.rm=TRUE toggle tells R to calculate the complete case mean. This is a biased measure of the mean, but missing data is a topic worthy of it’s own course. 1.3.2 Identifying Variable Types The str function is short for structure. This shows you the variable names, what data types R thinks each variable are, and some of the raw data. You can also use the view() function to open the data as a similar spreadsheet format, or head() to see the top 6 rows of the data. The latter is sometimes less than helpful for a very large data set. str(depress) ## &#39;data.frame&#39;: 294 obs. of 37 variables: ## $ id : int 1 2 3 4 5 6 7 8 9 10 ... ## $ sex : int 2 1 2 2 2 1 2 1 2 1 ... ## $ age : int 68 58 45 50 33 24 58 22 47 30 ... ## $ marital : int 5 3 2 3 4 2 2 1 2 2 ... ## $ educat : int 2 4 3 3 3 3 2 3 3 2 ... ## $ employ : int 4 1 1 3 1 1 5 1 4 1 ... ## $ income : int 4 15 28 9 35 11 11 9 23 35 ... ## $ relig : int 1 1 1 1 1 1 1 1 2 4 ... ## $ c1 : int 0 0 0 0 0 0 2 0 0 0 ... ## $ c2 : int 0 0 0 0 0 0 1 1 1 0 ... ## $ c3 : int 0 1 0 0 0 0 1 2 1 0 ... ## $ c4 : int 0 0 0 0 0 0 2 0 0 0 ... ## $ c5 : int 0 0 1 1 0 0 1 2 0 0 ... ## $ c6 : int 0 0 0 1 0 0 0 1 3 0 ... ## $ c7 : int 0 0 0 0 0 0 0 0 0 0 ... ## $ c8 : int 0 0 0 3 3 0 2 0 0 0 ... ## $ c9 : int 0 0 0 0 3 1 2 0 0 0 ... ## $ c10 : int 0 0 0 0 0 0 0 0 0 0 ... ## $ c11 : int 0 0 0 0 0 0 0 0 0 0 ... ## $ c12 : int 0 1 0 0 0 1 0 0 3 0 ... ## $ c13 : int 0 0 0 0 0 2 0 0 0 0 ... ## $ c14 : int 0 0 1 0 0 0 0 0 3 0 ... ## $ c15 : int 0 1 1 0 0 0 3 0 2 0 ... ## $ c16 : int 0 0 1 0 0 2 0 1 3 0 ... ## $ c17 : int 0 1 0 0 0 1 0 1 0 0 ... ## $ c18 : int 0 0 0 0 0 0 0 1 0 0 ... ## $ c19 : int 0 0 0 0 0 0 0 1 0 0 ... ## $ c20 : int 0 0 0 0 0 0 1 0 0 0 ... ## $ cesd : int 0 4 4 5 6 7 15 10 16 0 ... ## $ cases : int 0 0 0 0 0 0 0 0 1 0 ... ## $ drink : int 2 1 1 2 1 1 2 2 1 1 ... ## $ health : int 2 1 2 1 1 1 3 1 4 1 ... ## $ regdoc : int 1 1 1 1 1 1 1 2 1 1 ... ## $ treat : int 1 1 1 2 1 1 1 2 1 2 ... ## $ beddays : int 0 0 0 0 1 0 0 0 1 0 ... ## $ acuteill: int 0 0 0 0 1 1 1 1 0 0 ... ## $ chronill: int 1 1 0 1 0 1 1 0 1 0 ... Right away this tells me that R thinks all variables are numeric integers, not categorical variables. This will have to be changed. We’ll get to that in a moment. In SPSS you’ll the following set of icons to tell you what data types the program thinks each column is: Consider the variable that measures marital status. table(depress$marital) ## ## 1 2 3 4 5 ## 73 127 43 13 38 str(depress$marital) ## int [1:294] 5 3 2 3 4 2 2 1 2 2 ... class(depress$marital) ## [1] &quot;integer&quot; What data type does R see this variable as? When variables have numerical levels it is necessary to ensure that the program knows it is a factor variable. The following code uses the factor() function to take the marital status variable and convert it into a factor variable with specified labels that match the codebook. depress$marital &lt;- factor(depress$marital, labels = c(&quot;Never Married&quot;, &quot;Married&quot;, &quot;Divorced&quot;, &quot;Separated&quot;, &quot;Widowed&quot;)) It is important to confirm the recode worked. If it did not you will have to re-read in the raw data set again since the variable marital was replaced. table(depress$marital) ## ## Never Married Married Divorced Separated Widowed ## 73 127 43 13 38 class(depress$marital) ## [1] &quot;factor&quot; 1.3.3 Outliers Let’s look at the age variable in the depression data set. par(mfrow=c(1,2)) boxplot(depress$age) hist(depress$age) Just looking at the data graphically raises no red flags. The boxplot shows no outlying values and the histogram does not look wildly skewed. This is where knowledge about the data set is essential. The codebook does not provide a valid range for the data, but the description of the data starting on page 3 in the textbook clarifies that this data set is on adults. In the research world, this specifies 18 years or older. Now look back at the graphics. See anything odd? It appears as if the data go pretty far below 20, possibly below 18. Let’s check the numerical summary to get more details. summary(depress$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 9.00 28.00 42.50 44.38 59.00 89.00 The minimum value is a 9, which is outside the range of valid values for this variable. This is where you, as a statistician, data analyst or researcher goes back to the PI and asks for advice. Should this data be set to missing, or edited in a way that changes this data point into a valid piece of data. Another visual way to look for outliers in a continuous measurement is to create a boxplot. Here we look at boxplots of income across marital status category. ggplot(depress, aes(y=income, x=marital)) + geom_boxplot() While there are a few potential outliers (denoted by the dots), there are none so far away from the rest of the group (or at values such as 99 or -99 that may indicate missing codes) that we need to be concerned about. As an example of a common data entry error, and for demonstration purposes, I went in and changed a 19 to a 9. So the correct thing to do here is to change that 9, back to a 19. This is a very good use of the ifelse() function. depress$age &lt;- ifelse(depress$age==9, 19, depress$age) The logical statement is depress$age9. Wherever this is true, replace the value of depress$age with 19, wherever this is false then keep the value of depress$age unchanged (by “replacing” the new value with the same old value). Alternatively, you can change that one value using bracket notation. Here you are specifying that you only want the rows where age==9, and directly assign a value of 19 to those rows. depress$age[depress$age==9] &lt;- 19 Confirm the recode. summary(depress$age) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 18.00 28.00 42.50 44.41 59.00 89.00 Looks like it worked. 1.3.4 Creating secondary variables 1.3.4.1 Collapsing categorical variables into fewer categories For unbiased and accurate results of a statistical analysis, sufficient data has to be present. Often times once you start slicing and dicing the data to only look at certain groups, or if you are interested in the behavior of certain variables across levels of another variable, sometimes you start to run into small sample size problems. For example, consider marital status again. There are only 13 people who report being separated. This could potentially be too small of a group size for valid statistical analysis. One way to deal with insufficient data within a certain category is to collapse categories. The following code uses the recode() function from the car package to create a new variable that I am calling marital2 that combines the Divorced and Separated levels. library(car) marital2 &lt;- recode(depress$marital, &quot;&#39;Divorced&#39; = &#39;Sep/Div&#39;; &#39;Separated&#39; = &#39;Sep/Div&#39;&quot;) Always confirm your recodes. table(depress$marital, marital2, useNA=&quot;always&quot;) ## marital2 ## Married Never Married Sep/Div Widowed &lt;NA&gt; ## Never Married 0 73 0 0 0 ## Married 127 0 0 0 0 ## Divorced 0 0 43 0 0 ## Separated 0 0 13 0 0 ## Widowed 0 0 0 38 0 ## &lt;NA&gt; 0 0 0 0 0 This confirms that records where marital (rows) is Divorced or Separated have the value of Sep/Div for marital2 (columns). And that no missing data crept up in the process. Now I can drop the temporary marital2 variable and actually fix marital. (keeping it clean) depress$marital &lt;- recode(depress$marital, &quot;&#39;Divorced&#39; = &#39;Sep/Div&#39;; &#39;Separated&#39; = &#39;Sep/Div&#39;&quot;) rm(marital2) 1.3.4.2 Binning a continuous variable into categorical ranges. Let’s create a new variable that categorizes income into the following ranges: &lt;30, [30, 40), [40,50), [50, 60), 60+. The easiest way is to use the cut2 function in the package Hmisc. Note you don’t have to load the package fully to use a function from within that package. Useful for times when you only need to use a function once or twice. depress$inc_cut &lt;- Hmisc::cut2(depress$income, cuts=c(30,40,50,60)) table(depress$inc_cut) ## ## [ 2,30) [30,40) [40,50) [50,60) [60,65] ## 231 28 16 9 10 1.3.4.3 Dichotomizing a measure into 2 categories Dichotomous variables tend to be binary indicator variables where a code of 1 is the level you’re interested in. For example, gender is coded as 2=Female and 1=Male. This is in the right direction but it needs to be 0/1. depress$sex &lt;- depress$sex -1 table(depress$sex) ## ## 0 1 ## 111 183 0/1 binary coding is mandatory for many analyses. One simple reason is that now you can calculate the mean and interpret it as a proportion. mean(depress$sex) ## [1] 0.622449 62% of individuals in this data set are female. Sometimes the data is recorded as 1/2 (Yes/No), so just subtracting from 1 doesn’t create a positive indicator of the variable. For example, drink=1 if they are a regular drinker, and drink=2 if they are not. We want not drinking to be coded as 0, not 2. table(depress$drink) ## ## 1 2 ## 234 60 The ifelse() function says that if depress$DRINK has a value equal to 2 ==2, then change the value to 0. Otherwise leave it alone. depress$drink &lt;- ifelse(depress$drink==2, 0, depress$drink) table(depress$drink) ## ## 0 1 ## 60 234 1.3.4.4 Sum or Average values across multiple variables The Center for Epidemiological Studies Depression Scale (CESD) is series of questions asked to a person to measure their level of depression. CESD is calculated as the sum of all 20 component variables, and is already on this data set. Let’s create a new variable named sleep as subscale for sleep quality by adding up question numbers 5, 11, and 19. Reference: http://cesd-r.com/cesdr/ depress$sleep &lt;- depress$c5 + depress$c11 + depress$c19 ## # depress &lt;- depress %&gt;% mutate(sleep = c5+c11+c19) # Not run. dplyr example summary(depress$sleep) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.000 0.000 1.000 1.167 2.000 7.000 1.3.4.5 Transformations for Normality Let’s look at assessing normal distributions using the cleaned depression data set. hist(depress$income, prob=TRUE, xlab=&quot;Annual income (in thousands)&quot;, main=&quot;Histogram and Density curve of Income&quot;, ylab=&quot;&quot;) lines(density(depress$income), col=&quot;blue&quot;) summary(depress$income) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 2.00 9.00 15.00 20.57 28.00 65.00 The distribution of annual income is slightly skewed right with a mean of $20.5k per year and a median of $15k per year income. The range of values goes from $2k to $65k. Reported income above $40k appear to have been rounded to the nearest $10k, because there are noticeable peaks at $40k, $50k, and $60k. In general, transformations are more effective when the the standard deviation is large relative to the mean. One rule of thumb is if the sd/mean ratio is less than 1/4, a transformation may not be necessary. sd(depress$income) / mean(depress$income) ## [1] 0.743147 Alternatively Hoaglin, Mosteller and Tukey (1985) showed that if the largest observation divided by the smallest observation is over 2, then the data may not be sufficiently variable for the transformation to be decisive. max(depress$income) / (min(depress$income)+.1) ## [1] 30.95238 Note these rules are not meaningful for data without a natural zero. Another common method of assessing normality is to create a normal probability (or normal quantile) plot. qqnorm(depress$income);qqline(depress$income, col=&quot;red&quot;) The points on the normal probability plot do not follow the red reference line very well. The dots show a more curved, or U shaped form rather than following a linear line. This is another indication that the data is skewed and a transformation for normality should be created. Create three new variables: log10inc as the log base 10 of Income, loginc as the natural log of Income, and xincome which is equal to the negative of one divided by the cubic root of income. log10inc &lt;- log10(depress$income) loginc &lt;- log(depress$income) xincome &lt;- -1/(depress$income)^(-1/3) Create a single plot that display normal probability plots for the original, and each of the three transformations of income. Use the base graphics grid organizer par(mfrow=c(r,c)) where r is the number of rows and c is the number of columns. Which transformation does a better job of normalizing the distribution of Income? par(mfrow=c(2,2)) # Try (4,1) and (1,4) to see how this works. qqnorm(depress$income, main=&quot;Income&quot;); qqline(depress$income,col=&quot;blue&quot;) qqnorm(log10inc, main=&quot;Log 10&quot;); qqline(log10inc, col=&quot;blue&quot;) qqnorm(loginc, main = &quot;Natural Log&quot;); qqline(loginc, col=&quot;blue&quot;) qqnorm(xincome, main=&quot;-1/cuberoot(income)&quot;); qqline(xincome, col=&quot;blue&quot;) "],["saving-your-changes.html", "1.4 Saving your changes", " 1.4 Saving your changes You’ve just made a ton of changes! Save or export the new data set to your computer. Edit the codebook to reflect the changes that you made. In a production situation, or when changes aren’t being made on a rapid basis, it is common to include the date in the file name. Keep the data, codebook and data management file in the same folder. The Sys.Date() function takes the current date from your computer. The value is then formatted nicely for human consumption and added (pasted) to the file name before written to the working directory as a new text file. depress_clean &lt;- depress %&gt;% select(var1, var2, var3) date &lt;- format(Sys.Date(), &quot;%m%d%y&quot;) filename &lt;- paste(&quot;depress_&quot;, date, &quot;.txt&quot;, sep=&quot;&quot;) write.table(depress_clean, filename, sep=&quot;\\t&quot;, row.names=FALSE) SPSS users commonly save cleaned data as a .sav format. SAVE outfile=&#39;FilePath\\depress_sysdate.sav&#39; /KEEP = Variable_Name1 Variable_Name2. EXECUTE. Saving only selected variables In SPSS the /KEEP statement demonstrated above only writes the variable names listed to the saved data set. This can be very useful when dealing with data sets with a large number of variables. For R users, using dplyr select is generally the fastest. "],["wide-long.html", "1.5 Wide vs. Long data", " 1.5 Wide vs. Long data The data on Lung function originally was recorded in wide format, with separate variables for mother’s and father’s FEV1 score (MFEV1 and FFEV). In this format, the data is one record per family. fev &lt;- read.delim(&quot;https://norcalbiostat.netlify.com/data/Lung_081217.txt&quot;, sep=&quot;\\t&quot;, header=TRUE) head(fev) ## ID AREA FSEX FAGE FHEIGHT FWEIGHT FFVC FFEV1 MSEX MAGE MHEIGHT MWEIGHT MFVC ## 1 1 1 1 53 61 161 391 3.23 2 43 62 136 370 ## 2 2 1 1 40 72 198 441 3.95 2 38 66 160 411 ## 3 3 1 1 26 69 210 445 3.47 2 27 59 114 309 ## 4 4 1 1 34 68 187 433 3.74 2 36 58 123 265 ## 5 5 1 1 46 61 121 354 2.90 2 39 62 128 245 ## 6 6 1 1 44 72 153 610 4.91 2 36 66 125 349 ## MFEV1 OCSEX OCAGE OCHEIGHT OCWEIGHT OCFVC OCFEV1 MCSEX MCAGE MCHEIGHT ## 1 3.31 2 12 59 115 296 2.79 NA NA NA ## 2 3.47 1 10 56 66 323 2.39 NA NA NA ## 3 2.65 1 8 50 59 114 1.11 NA NA NA ## 4 2.06 2 11 57 106 256 1.85 1 9 49 ## 5 2.33 1 16 61 88 260 2.47 2 12 60 ## 6 3.06 1 15 67 100 389 3.55 1 13 57 ## MCWEIGHT MCFVC MCFEV1 YCSEX YCAGE YCHEIGHT YCWEIGHT YCFVC YCFEV1 ## 1 NA NA NA NA NA NA NA NA NA ## 2 NA NA NA NA NA NA NA NA NA ## 3 NA NA NA NA NA NA NA NA NA ## 4 56 159 1.30 NA NA NA NA NA NA ## 5 85 268 2.34 2 10 50 53 154 1.43 ## 6 87 276 2.37 2 10 55 72 195 1.69 To analyze the effect of gender on FEV, the data need to be in long format, with a single variable for fev and a separate variable for gender. The following code chunk demonstrates one method of combining data on height, gender, age and FEV1 for both males and females. fev2 &lt;- data.frame(gender = c(fev$FSEX, fev$MSEX), rev = c(fev$FFEV1, fev$MFEV1), ht = c(fev$FHEIGHT, fev$MHEIGHT), age = c(fev$FAGE, fev$MAGE)) fev2$gender &lt;- factor(fev2$gender, labels=c(&quot;M&quot;, &quot;F&quot;)) head(fev2) ## gender rev ht age ## 1 M 3.23 61 53 ## 2 M 3.95 72 40 ## 3 M 3.47 69 26 ## 4 M 3.74 68 34 ## 5 M 2.90 61 46 ## 6 M 4.91 72 44 Nearly all analysis procedures and most graphing procedures require the data to be in long format. There are several R packages that can help with this including reshape2 and tidyr. "],["dealing-with-missing-data-post-analysis.html", "1.6 Dealing with missing data post-analysis", " 1.6 Dealing with missing data post-analysis Situation: You want to add model predictions to the data set, but you have missing data that was automatically dropped prior to analysis. 1.6.1 Regression R objects created by methods such as lm and glm will store the data used in the model in the model object itself in model$data. See Chapter 12 for an example. 1.6.2 Factor Analysis and Principle Components If your original data had missing values, here is one way to get the PC’s / factor scores for available data back onto the data set. Method 1) Create an ID column and merge new variables onto original data. (add columns) If no ID column exists, create one on the original dataset id = 1:NROW(data) Use select() to extract the ID and all variables used in the factor analysis, then do a na.omit() to drop rows with any missing data. Save this as a new complete case data set. Conduct PCA / Factor analysis on this new complete case data set (MINUS THE ID). Extract the PCs or factor scores. Use bind_cols() to add the ID variable to the data containing factor scores. Then left_join(original_data, factor_score_data) the factor scores back to the original data, using the ID variable as the joining key. Method 2) Split the data, analyze one part then concatenate back together. (add rows) Use the complete.cases() function to create a boolean vector for if each row is complete Split the data into complete and incomplete. Do the analysis on the complete rows, extracting the PC’s/Factors Add the PC/Factor data onto the complete rows using bind_cols Then bind_rows the two parts back together. cc.idx &lt;- hiv %&gt;% select(starts_with(&quot;pb&quot;)) %&gt;% complete.cases() # 1 complete.rows &lt;- hiv[cc.idx,] #2 incomplete.rows &lt;- hiv[!cc.idx,] pc.scores &lt;- princomp(pb)$scores #3 complete.add.pc &lt;- bind_cols(complete.rows, pc.scores) #4 hiv.with.pcs &lt;- bind_rows(complete.add.pc, incomplete.rows) #5 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
